## 堆

1. 堆结构就是用数组实现的完全二叉树结构
2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
4. 堆结构的 *heapInsert* 与 *heapify* 操作
5. 堆结构的增大和减少
6. 优先级队列结构，就是堆结构



## 排序算法

|     排序方法     | 时间复杂度（平均） | 时间复杂度（最差） | 额外空间复杂度 | 稳定性 |
| :--------------: | :----------------: | :----------------: | :------------: | :----: |
|     选择排序     |      O(N^2^)       |      O(N^2^)       |      O(1)      | 不稳定 |
|     冒泡排序     |      O(N^2^)       |      O(N^2^)       |      O(1)      |  稳定  |
|     插入排序     |      O(N^2^)       |      O(N^2^)       |      O(1)      |  稳定  |
|     归并排序     |      O(NlogN)      |      O(N^2^)       |      O(N)      |  稳定  |
| 快速排序（随机） |      O(NlogN)      |      O(N^2^)       |    O(logN)     | 不稳定 |
|      堆排序      |      O(NlogN)      |      O(NlogN)      |      O(1)      | 不稳定 |

- 稳定性：同样值的个体（基本数据类型）之间，如果不因为排序而改变相对次序，则此排序具有稳定性，反之则无
- 不具备稳定性的排序：选择排序、快速排序、堆排序
- 具备稳定性的排序：冒泡排序、插入排序、归并排序、一切桶排序思想下的排序
- 常见的坑：
  1. 归并排序的额外空间复杂度可以变成 O(1)，但是非常难，不需要掌握，有兴趣可以搜”归并排序内部缓存法”
  2. “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成 O(N^2^)
  3. 快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01stable sort”
  4. 所有的改进都不重要，因为目前没有找到时间复杂度 O(NlogN)，额外空间复杂度 O(1)，且具有稳定性的排序
  5. 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。因为即使从思想层面上可实现，依据快速排序的思想，只不过区域划分的标准从按大小关系划分变成了按奇偶性划分，但是稳定性肯定不能保证，若要稳定，则时间复杂度会变为 O(N^2^)，且实现上是论文级别的难度
- 工程上对排序的改进：
  1. 充分利用 O(NlogN) 和 O(N^2^) 排序各自的优势：
     - 大样本量时，利用 O(NlogN) 排序调度快的时间复杂度上的优势
     - 小样本量时，利用 O(N^2^) 排序时间复杂度表达式上常数项小的优势
     - 将上述两个优势结合形成综合排序，小样本量时直接使用插入排序，大样本量时使用快速排序
  2. 稳定性的考虑：
     - 基础类型用快排，因为考虑稳定性无意义，所以使用常数时间较低的快排
     - 非基础类型用归并，因为需要考虑稳定性



## 链表

- 面试时链表解题的方法论：
  1. 对于笔试，不用太在乎空间复杂度，一切为了时间复杂度
  2. 对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法
- 重要技巧：
  1. 额外数据结构记录（哈希表等）
  2. 快慢指针



## 暴力递归

暴力递归就是尝试

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件（base case）
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解