## CommonJS

- `CommonJS规范`使用`exports`导出模块，`require`导入模块，具体规范如下：

  1. 如果一个js文件中存在`exports`或`require`，则该js文件是一个模块
  2. 模块内的所有代码均为隐藏代码，包括全局变量、全局函数，这些全局的内容均不应该对全局变量造成任何污染
  3. 如果一个模块需要暴露一些api给外部使用，则通过`exports`导出，`exports`是一个空对象，可以为该对象添加任何需要导出的内容
  4. 如果一个模块需要导入其它模块，则通过`require`导入，`require`是一个函数，传入模块的路径即可返回该模块导出的整个内容

- 为实现`CommonJS规范`，nodejs对模块做了以下处理：

  1. 为保证高效地运行，仅加载必要的模块。nodejs只有执行到`require`函数时才会加载并执行模块

  2. 为隐藏模块中的代码，nodejs执行模块时，会将模块中的所有代码放置到一个函数环境中执行（可暂时看作是在一个立即执行函数中运行，但实际上不是），以保证不污染全局变量

     ```js
     (() => {
         // 模块中的代码
     })();
     ```

  3. 为保证顺利地导出模块内容，nodejs做以下处理：

     1. 在模块开始执行前，初始化一个值`module.exports = {}`

     2. `module.exports`即模块的导出值

     3. 为方便开发者便捷地导出，nodejs在初始化完`module.exports`后，又声明了一个变量`exports = module.exports`

        ```js
        ((module) => {
        	module.exports = {};
            const exports = module.exports;
            // 模块中的代码
            return module.exports;
        })();
        ```

     4. 为避免反复加载同一个模块，nodejs默认开启了模块缓存，如果加载的模块已经被加载过了（记录在缓存列表），则会自动使用之前的导出结果


## AMD规范和CMD规范

- 可以认为CommonJS是同步的，必须要等到加载完文件并执行完代码后才能继续向后执行，则CommonJS在浏览器端实现时就存在以下问题：

  1. 浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率。由于CommonJS是同步的，这会极大的降低运行性能
  2. 如果需要读取JS文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，但浏览器厂商不愿意提供支持，最大的原因是CommonJS属于社区标准，并非官方标准

- 基于以上两点原因，浏览器无法支持模块化，但不代表模块化无法在浏览器端实现。想要实现则只需解决以上两问题：

  1. 远程同步加载JS浪费效率？采取异步加载的方式，加载完成后调用一个回调函数

  2. 模块中的代码需要放置到函数环境中执行？在编写模块时，可直接将需执行的代码放置在函数环境中

     基于这种思路，便出现了下述的社区产生的AMD规范和CMD规范

- **AMD规范**：

  - 全称：Asynchronous Module Definition 异步模块定义规范

  - require.js实现了AMD规范，在页面中引入require.js并于同一script标签上使用自定义属性定义入口文件data-main="xxx"

  - 在AMD中，导入和导出模块的代码都必须放置在define函数中

    ```js
    define([依赖的模块列表], function (模块名称列表) {
    	// 模块内部代码
        return 导出的内容;
    });
    ```

- **CMD规范**：

  - 全称：Common Module Definition 公共模块定义规范

  - sea.js实现了CMD规范，在页面中引入require.js并于另一script标签内引入入口文件

  - 在CMD中，导入和导出模块的代码都必须放置在define函数中

    ```js
    define(function (require, exports, module) {
        // 模块内部代码
    });
    ```

## ES6模块化

- **ES6模块化具有以下特点**：

  1. 使用依赖**预声明**的方式导入模块
     1. 依赖延迟声明（CommonJS使用）：
        - 优点：某些时候可以提高效率
        - 缺点：无法在一开始确定模块依赖关系
     2. 依赖预声明（ES6模块化使用）：
        - 优点：在一开始可以确定模块依赖关系
        - 缺点：某些时候效率较低
  2. 灵活的多种导入导出方式
  3. 规范的路径表示法：所有路径必须以`./`或`../`开头

- **基本导入导出**：

  - 模块的引入：目前浏览器使用以下方式（非模块化标准）引入一个ES6模块文件：

    ```html
    <script src="入口文件" type="module">
    ```

  - 模块的基本导出和导入：

    - **基本导出**：（类似于export.xx = xxx）

      - 基本导出可以有多个，每个都必须有名称

      - 基本导出的语法如下：

        ```js
        export 声明表达式;
        // 或
        export { 具名符号 };
        
        // 由于基本导出必须具有名称，所以要求导出内容必须跟上声明表达式或具名符号
        ```

    - **基本导入**：

      - 由于使用的时依赖预声明，则在导入任何其它模块时，导入代码必须放置在所有代码之前

      - 基本导入的语法如下：

        ```js
        import { 导入的符号列表 } from "模块路径";
        
        // 注意点：
        // 1.导入时可以通过关键字as对导入的符号进行重命名
        import { 原符号名 as 新符号名 } from "模块路径";
        // 2.导入时使用的符号是常量，不可修改
        // 3.可以使用*号导入所有的基本导出，形成一个对象
        import * as obj from "模块路径";
        ```

- **默认导入导出**：

  - **默认导出**：

    - 每个模块，除了允许有多个基本导出以外，还允许有一个默认导出。默认导出类似于CommonJS中的module.exports，由于只有一个，因此无需具名

    - 语法：

      ```js
      export default 默认导出的数据;	// 这种写法是下面写法的语法糖
      // 或
      export { 默认导出的数据 as default };
      ```

    - 由于每个模块仅允许一个默认导出，因此每个模块不能出现多个默认导出语句

  - **默认导入**：

    - 语法：

      ```js
      import 接收变量名 from "模块路径";
      // 类似于CommonJS中的 const 接收变量名 = require("模块路径")
      ```

    - 由于默认导入时变量名是自行定义的，所以没有别名。

    - 若要同时导入某个模块的默认导出和基本导出，则可以：

      ```js
      import 接收默认导出的变量, { 接收基本导出的变量 } from "模块路径"; // 是下面写法的语法糖
      // 或
      import { 接收基本导出的变量, default as 接收默认导出的变量 } from "模块路径";
      
      // 还可以使用*号将所有的基本导出和默认导出聚合到一个对象中
      import * as data from "模块路径";
      data.default; // 默认导出会作为属性default存在于该对象中
      ```
      

- **其它细节**：

  1. 尽量导出不可变值

     虽然导入内容在导入后无法被更改，但是在导入的模块内部却有可能产生对导入内容的更改，这将导致一些无法预料的问题

  2. 可以使用无绑定的导入用于执行一些初始化代码

     只想执行模块中的一些代码而不需要导入它的内容，则可以使用无绑定的导入：

     ```js
     import "模块路径";
     ```

  3. 可以使用绑定再导出，来重新导出来自另一个模块的内容

     有时需要用一个模块封装多个模块，然后有选择地将多个模块的内容分别导出，可以：

     ```js
     export { 绑定的标识符 } from "模块路径";
     ```



## 前端构建工具

- *第一代前端构建工具*

  - 是以 *NPM scripts*、*Grunt* 以及 *Gulp* 为代表的构建工具，该时期要做的事情相对较少，主要是代码转换和压缩。从功能上分类属于**任务流工具**

  - 其中 *Gulp* 相比 *Grunt* 是后起之秀，它吸取了 *Grunt* 的优点，拥有更简便的写法，通过流（Stream）的概念来简化多任务之间的配置和输出，让任务更加简洁和容易上手

  - 相比于 *Grunt* 的频繁的 *IO* 操作，*Gulp* 的流操作，能更快地完成构建。另外学习曲线也比较平滑。比 *Grunt* 速度更快、配置更少

    > *Gulp* 的使用参阅文档《*Gulp* 快速上手教程》

- *第二代前端构建工具*

  - 是以 *browserify*、*webpack*、*parcel* 以及 *rollup* 为代表的构建工具，随着前端模块化的发展、单页应用变主流，该时期的构建工具的显著特点就是对模块进行打包，并且提供的功能越来越完整，包含代码分割、*tree-shaking*、*source-map* 等一系列的功能。从功能分类上属于**模块打包工具**

  - *browserify*

    - *browserify*是最早期的模块打包工具，也是模块打包中的先驱者
    - 出现时期 ES Module 还没成为 ECMA Script 的统一规范，所以该构建工具最大的特点就是能让开发人员能够使用 *CommonJS* 规范来做代码的模块化，那个时期非常流行的构建方式就是 *browserify + gulp* 的构建方式，*gulp* 负责将文件转码、压缩，*browserify* 负责进行打包

  - *webpack*

    - *webpack* 是后起之秀，它支持了多种模块化类型，是一个为前端模块打包构建而生的工具

    - 它既吸取了大量已有方案的优点与教训，也解决了很多前端开发过程中已存在的痛点，如代码的拆分与异步加载、对非 *JavaScript* 资源的支持等。强大的 *loader* 设计使得它更像是一个构建平台，而不只是一个打包工具

    - 优点很多，缺点有配置复杂、大型项目构建慢等

      > 使用 *webpack* 搭建 *vue* 应用可参阅文档《使用 *vue+webpack* 搭建 *vue* 应用》

  - *parcel*

    - *parcel* 的出现是为了解决webpack上述的两大痛点，主打*极速零配置*

    - 内置了 *html、babel、typescript、less、sass、vue* 等功能，无需配置，并且不同于 *webpack* 只能将 *js* 文件作为入口，在 *parcel* 中万物皆资源，所以 *html* 文件 *css* 文件都可以作为入口来打包

    - 所以不同于 *webpack* 的复杂配置，只需要一个 *parcel index.html* 命令就可以直接启动一个自带热更新的 *server* 来开发 *vue/react* 项目

    - 另外，针对 *webpack* 大型项目构建慢这一点，*parcel* 也做了很多优化，例如 *parcel* 使用 *worker* 进程去启用多核编译，并且使用文件来缓存编译后的模块

    - 缺点：无法轻松的对构建工作进行定制化，如果想要配置一些复杂的构建功能就会非常麻烦

      > *parcel* 的使用可参阅《Parcel 快速上手教程》

  - *rollup*
    - ES6 发布后 *rollup* 应声而出，*rollup* 可以编译 *ES6* 模块，提出了 *Tree-shaking*，根据 *ES module* 静态语法特性，删除未被实际使用的代码，支持导出多种规范语法，并且导出的代码非常简洁，所以这可以算是 *rollup* 的一个最大特点
    - 另外，相比于 *browserify* 的 *CommonJs*，*rollup* 专注于 *ES module*，并且相比于 *webpack* 大而全的前端工程化，*rollup* 更加专注于纯 *javascript* 的打包工作，所以 *rollup* 大多被用作打包 *tool* 工具或 *library* 库

- *第三代前端构建工具*

  - 是以 *Snowpack* 和 *Vite* 为代表的构建工具。主要为了解决开发阶段大型项目运行前打包时长过长非常耗时的问题，解决开发者的烦恼。

  - *Vite*

    - *Vite* 是一个基于浏览器原生 *ES Module* 的开发服务器

    - 利用浏览器去解析 *imports*（模块中的 *import* 引入的其它模块的内容文件），在服务器端按需编译返回，完全跳过了打包这个概念，服务器随启随用

      > *Vite* 的使用可参阅《*Vite* 快速上手教程》
