## IP地址

格式：

- 分为四段：xxx.xxx.xxx.xxx，每段取值0~255，即256进制一字节
- 一个IP地址分为两部分：第一段为网络ID，后三段为主机ID

分类：

- A类：0.0.0.0 ~ 127.255.255.255	（一个网络有2^24台主机）
- B类：128.0.0.0 ~ 191.255.255.255
- C类：192.0.0.0 ~ 223.255.255.255
- D类：多播地址（或组播地址）
- E类：

A、B、C类地址都是统一发放的，一般家里的路由器由网络运营商分配一个公网C类IP，然后再由路由器给连接上其的设备分配私有地址（局域网地址）,多为 192.168.xxx.xxx



## 域名与DNS解析

域名例如www.baidu.com，是不可以直接通过其访问到相应服务器的，而是要通过域名与IP的映射获取IP地址然后进行访问。

当向浏览器的地址栏中输入一个url后进行访问，网络中都会发生什么？

答：逐层次冒泡向上查找与之对应的IP地址，顺序为：浏览器的缓存、本机host（C:windows/system32/drivers/etc/host	127.0.0.1 localhost 代表本机）、家里局域网的服务器、上级路由、城市的LDNS服务器（local）、继续上级DNS服务器直到GDNS服务器（global）



## 五层网络模型

1. 物理层：将数据转换为可通过物理介质传送的电子信号
2. 数据链路层：MAC地址
3. 网络层：IP地址——IP协议
4. 运输层：TCP协议、UDP协议
5. 应用层：HTTP协议、DNS协议

当与外部服务器进行数据交换时，例如：发送数据需要将数据自上而下包裹各层次协议（物理层（IP协议（TCP协议（HTTP协议 请求头（数据））））），服务器端接受数据则自下而上分解各层次协议而获得数据



## HTTP协议

- 请求报文：

  - 格式：请求方式	url	协议及版本	=>	请求行

    ​			键：值									=>	首部行（请求头）

    ​			键=值&键=值						 =>	实体主体（请求体）

  - 请求方式有GET/POST（常用）HEAD/PUT/DELETE（不常用）

  - 例：GET /path?a=1&b=2 HTTP1.1

    ​		Host: www.baidu.com

    ​		Connection: keep-alive（表示长连接）

    ​		User-Agent: ...

    ​				...


- 数据体（请求体）：

    - GET方式传输的参数都在url里，信息量不大在几kb左右，数据体基本上没其它信息，所以传输不了大文件（PS：HTTP协议理论上GET传输的参数可以不在url中，但现代使用的是基于web环境下的HTTP协议，其要求GET请求的参数都在url里）
    - POST方式传输的参数都在数据体里，传输大文件优先采用

- 响应报文：

  - 格式：协议及版本	状态码	短语	=>	状态行

    ​			键：值									  =>	首部行（响应头）
    
    ​			JSON数据								 =>	实体主体（响应体）

  - 数据体：



## GET与POST请求方式的区别

1. 是基于什么前提的？

   若无任何前提，不使用任何规范，只考虑语法和理论上的HTTP协议，则GET和POST几乎没有什么区别，只是名字不同

2. 若是基于RFC规范的

   1. 理论上的（Specification）：GET和POST具有相同语法，但有不同语义。GET用来获取数据，POST用来发送数据，其余方面无差别

   2. 实现上的（Implementation）：各种浏览器就是这个规范的实现者

      常见的那些不同：

      1. GET的请求数据在URL中是可见的（并不全部显示在地址栏），POST的则不显示在URL中

      2. GET对长度有限制，POST长度无限

      3. GET请求的数据可被收藏为书签，POST请求的数据则不可被收藏为书签

      4. GET请求后，后退、刷新按钮对其数据无影响，POST的数据则会被重新提交

      5. GET编码类型：application/x-www-form-url

         POST编码类型：有多种，常用的有：encodeapplication/x-www-form-urlencoded

         ​																multipart/form-data

      6. GET历史参数会被保留在浏览器里，POST则不会

      7. GET的传送数据只允许ASCII编码，POST则没有编码限制，且允许传送二进制数据

      8. GET与POST相比，GET安全性较差（但二者在HTTP协议下都是明文传送），因其所发的数据为URL的一部分



## Cookie与Session

保持登录状态如何做到的？

按照正常的HTTP协议是做不到的，因为HTTP协议是上下文无关协议，所以前端页面上存在可以持久化存储数据的东西，一旦登录之后便会将登录信息存储在其中

- Cookie

  Cookie是存放在浏览器中的，更是存放在不同的域名下的，不能跨域，可以长期存放

  由Cookie实现的自动登录的过程：

  1. 初始状态：没有登录
  2. 访问百度的登录，键入用户名和密码
  3. 如果用户名和密码正确匹配，则百度的后端会向这个域名下设置一个Cookie，并写入用户的基本信息（加密的）
  4. 之后每一次向百度发送请求，浏览器都会自动带上这些Cookie
  5. 服务器（后端）接收到带有ID的Cookie，就可以解析这个加密过的ID以获取用户本身的ID
  6. 如果能获取到本身的ID，则证明该用户已经登录过，所以后端可以继续保留用户的信息

  缺点：若浏览器中的Cookie被非法窃取，对方就可以在其电脑上登录用户的账号

- Seesion

  Seesion携带的用户信息存放在服务器端，不易被非法窃取安全性高

  缺点有：

  1. Seesion需要存放在ram，若用户量级很大，非常消耗服务器的资源
  2. 后端不止一台服务器，但用户信息一般只存在于其执行登录操作的那一台服务器上，且该操作需要通过反向代理（轮询，IP哈希）（IP Hash技术能够将某个IP的请求定向到同一台后端web机器中,这样一来这个IP下的客户端和某个后端web机器就能建立起稳固的session）



## 页面的正确打开方式

- B/S结构	Browser/Server结构——Browser负责内容的展示，Server负责提供内容

- C/S结构    Client/Server结构——Client负责内容的展示，Server负责展示内容

- web页面的本质是一个字符串，带有HTML格式的字符串

- 浏览器向服务器请求一个页面的本质？

  1. 键入url后进行网络请求
  2. 服务器接收到这个请求后，要将该页面的内容（HTML格式的字符串）返回给浏览器
  3. 页面的字符串存储在HTML文件中。例如：xxx.html
  4. 服务器端读取文件
  5. 将读取出来的内容返回给浏览器

  请求所返回的字符串的来源可能是文件，浏览器缓存，数据库

- 服务器：严格意义上服务器是一台提供计算和应用服务的计算机，而我们常说的服务器则是指服务容器

- 服务容器：是一个程序，程序可以监听一个端口（且一个端口仅能被一个程序监听），当用户向服务器发送网络请求时则是由服务容器监听到，然后服务器读取文件然后返回给用户

- 若想要通过访问服务器（服务容器）的方式来访问自己写的网页则要安装一个服务容器的程序



## 发送网络请求

1. 浏览器中直接输入网址
2. location.href="url"，可以发出网络请求，但页面会发生跳转
3. 带有src属性的标签，例如img、script标签。可以发出请求，服务端可处理也可返回，但是返回结果能否被运用取决于浏览器
4. 带有href属性的标签，例如link标签。同上。（src和href属性都是通过get方式发出的请求）
5. 带有action属性的标签，例如form表单。可以发出请求，但页面会发生跳转
6. ajax（Asynchronous Javascript And XML）



## 跨域

- 跨域的定义：

  **同源策略**是浏览器的一种安全策略，所谓同源是指协议、顶级域名、端口完全相同，只有同源的地址才可以相互通过ajax的方式请求，不同源则为跨域请求

- 允许被跨域请求的资源：

  具有src属性的文件（js文件、图片等）、具有href属性的文件（大部分可以，如css文件等）

- 不允许被跨域请求的资源：
  - 从后端接口请求的数据
  - 其它域的Cookie
  - 其它域的缓存

- 跨域的行为发生在哪？
  - 即使发生了跨域，请求也可正常发出
  - 服务器端可以接受，可以正常处理，可以正常返回数据
  - 浏览器可以接收到返回的数据
  - 接受数据后，辨别出当前页面的域与请求的域不同，则判定为跨域
  - 数据不会再传递给需要执行的代码段

- 解决跨域问题：
  - 后端配合用户进行跨域
    - JSONP（一般情况下返回的数据都是JSON格式，后端要经过处理将其转换为JSONP格式）
    - 后端设置Access-Control-Allow-Origin属性以支持跨域
  - 后端不配合用户进行跨域
    - iframe（只能显示页面，不能通过js来操作）
    - 通过后端代理（用户的后端）



## 跨域的解决方案

### CORS

cors（cross-origin resource sharing）跨域资源共享

- 特点：

  后端返回的响应头会自动携带 `Access-Control-Allow-Origin`字段

- 实现过程：

  整个CORS通信过程，都是浏览器自动完成，对于开发者来说，CORS通信与同源的AJAX通信没有差别，浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉，只是在被请求的源是否允许指定域请求

- cors的两种请求方式：

  - 简单请求

    同时满足以下两条件即属于简单请求:

    1. 请求方法是以下三种方法之一：

       HEAD、GET、POST

    2. HTTP的头信息不超出以下几种字段：

       - Accept
       - Accept-Language
       - Content-Language
       - Last-Event-ID
       - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

  - 非简单请求/复杂请求

    - 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`
    - 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）
    - 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，返回状态码204，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错，返回状态码405



### JSONP

- JSONP格式：

  进行网络请求时会附带参数callback，返回的jsonp格式则是`callback名字 + ( + json + )`

- 特点：

  - 只接受GET请求的形式

    jsonp跨域只能使用get，若设置为post则jQuery自动更改为get。而并不是jsonp只能使用get，当jQuery判断是否同源（即是否跨域）的结果为同源（即非跨域）时，设置为get/post即为get/post，若非同源则设置get/post都为get

  - 需要与后端进行请求参数的约定

  - 有参数数据大小的限制

  - 不是一个真正的ajax请求

- JSONP原理

  1. 判断请求与当前页面的域是否同源，若同源则以正常ajax形式进行请求

  2. 不同源则生成一个script标签，生成一个随机的callback名字，且创建一个以此为名的全局函数

  3. 将该script标签的src属性设置为要请求的接口，且将callback作为附带请求参数拼接上

     上述为前端部分

  4. 后端接受到请求后，将要返回的数据用callback的值和括号包裹起来（即以JSONP的格式封装）

  5. 返回数据

     上述为后端部分

  6. 浏览器接受到数据后将其作为js代码执行，即执行一个参数为JSON对象函数名为随机callback的函数



### proxy代理

- 实现：

  本地开启代理服务器，前端代码在代理环境下进行开发，请求由代理服务器进行转发，服务器与服务器之间不涉及到跨域问题

- 常见的代理方式：

  - liveServer：IDE的三方插件
  - webpack devServer：前端工程化构建工具
  - nginx：nginx服务器代理



### iframe跨域

- postMessage：该方法为html5扩展的API，允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递
- 实现：
  - 父页面向子页面进行数据传递
    1. 父页面找到iframe标签，为ifrme的window（通过iframe.contentWindow获取）定义绑定postMessage事件（必须保证页面全部加载完成之后使用该事件，所以应在iframe.onload下绑定）
    2. 子页面window进行message事件的监听，通过回调函数获取父页面传递的信息
  - 子页面向父页面进行数据传递
    1. 子页面获取父页面的window（通过window.parent获取），进行postMessage事件注册
    2. 父页面window进行message事件的监听，通过回调函数获取子页面传递的信息



## TCP

- 定义：

  TCP协议，即传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议

- TCP通信需要经过**创建连接、数据传送、终止连接**三个步骤，TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据

- 特点：
  1. 面向连接
  2. 传输可靠
     - TCP采用发送应答机制
     - 超时重传
     - 错误校验
     - 流量控制和阻塞管理



## 三次握手和四次挥手

### **三次握手**：

- 不同http版本中三次握手表现

  - http 1.0

    http请求创建的时候同时创建了tcp连接，请求发送，服务器响应之后，tcp连接关闭

  - http 1.1

    通过声明的方式（Keep alive），保持连接（节省tcp连接开销）

  - http 2.0

    http请求可以处理并发,只需要一个tcp连接就可以了

- tcp中的标志位、序列号
  - SYN（synchronous建立联机标志位）
  - ACK（acknowledgement 联机确认标志位）
  - Sequence number（顺序号码，数据包的序号）
  - Acknowledge number（确认号码，响应数据包的序号）
  - FIN（finish结束，终止链路标志位）

- 实现：

  <img src="https://adminimg.hyfarsight.com/v2-576b043d12353928eea6e45373655668_720w.jpg" alt="img" style="zoom: 75%"/>

  1. **第一次握手**：

     客户端协议栈向服务器端发送了 `SYN` 包，并告诉服务器端当前发送序列号 SYN = 1, seq=x，x为本次TCP通信的字节流的初始序号, 客户端进入 SYN_SENT 状态

  2. **第二次握手**：

     服务器端的协议栈收到这个包之后，和客户端进行 `ACK `应答，应答的值为 `x+1`，表示 对 SYN 包 1的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号 为 1，服务器端进入 `SYNC_RCVD` 状态

  3. **第三次握手**：

     客户端协议栈收到 `ACK` 之后，还要向服务端发送一个确认报文段, 表示：服务端发来的连接同意应答已经成功收到，表示客户端到服务器端的单向连接建立成功，客户端发完这个报文段后便进入ESTABLISHED状态，此时连接的建立完成,该报文段的头部为：ACK=1，seq=x+1，ack=y+1, 这个时候服务器端到客户端的单向连接也建立成功，服务端收到这个应答后进入ESTABLISHED状态

  4. 图示：

  <img src="https://adminimg.hyfarsight.com/1643a1dd6df4813b" alt="img" style="zoom: 45%;" />

  <img src="https://adminimg.hyfarsight.com/1643a1f3fa6c21b0" alt="img" style="zoom:45%;" />

- 为什么会有三次握手？

  - 第一种情况：

    若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是“失效的“

  - 第二种情况：

    客户端影响不大，仍然需要获得服务端的应答后才进入ESTABLISHED状态，如果网络拥塞，服务端收到请求才会进入ESTABLISHED状态，此时的客户端早已进入CLOSED状态，服务端一直等待下去



### 四次挥手：

- 实现：

  <img src="https://pic1.zhimg.com/80/v2-c8b61ed2a249700583b11bc5d16c5711_720w.jpg?source=1940ef5c" alt="img" style="zoom: 75%;" />

  1. **第一次挥手**：
  
     客户端数据发送完成，需要向服务端发送连接释放请求。请求只有报文头
  
  2. **第二次挥手**：
  
     服务端接收到释放请求，通知相应程序，客户端要进行关闭。此时服务端进入CLOSE-WAIT状态，并向客户端发送连接释放的应答
  
  3. **第三次挥手**：
  
     当服务端向客户端发送完所有数据后，开始向客户端发送连接释放请求，此时服务端进行LAST-ACK状态
  
  4. **第四次挥手**：
  
     客户端接收释放请求后，向服务端发送确认应答，客户端进入TIME-WAIT状态。该状态会持续2MSL时间，服务端没有后续数据发送，进入CLOSED状态，撤销TCB。服务端收到确认应答后，也便进入CLOSED状态，撤销TCB
  
  5. 图示：
  
  <img src="https://adminimg.hyfarsight.com/1643a20296de1ff0" alt="img" style="zoom: 45%;" />
  
  <img src="https://adminimg.hyfarsight.com/1643b1147fbbc5e7" alt="img" style="zoom: 45%;" />

