## IP

### 格式

- 分为四段：xxx.xxx.xxx.xxx，每段取值0~255，即256进制一字节
- 一个IP地址分为两部分：第一段为网络ID，后三段为主机ID

### 分类

- A类：0.0.0.0 ~ 127.255.255.255	（一个网络有2^24台主机）
- B类：128.0.0.0 ~ 191.255.255.255
- C类：192.0.0.0 ~ 223.255.255.255
- D类：多播地址（或组播地址）
- E类：

A、B、C类地址都是统一发放的，一般家里的路由器由网络运营商分配一个公网C类IP，然后再由路由器给连接上其的设备分配私有地址（局域网地址），多为 192.168.xxx.xxx



## 域名与 DNS 解析

域名例如www.baidu.com，是不可以直接通过其访问到相应服务器的，而是要通过域名与IP的映射获取IP地址然后进行访问。

当向浏览器的地址栏中输入一个url后进行访问，网络中都会发生什么？

答：逐层次冒泡向上查找与之对应的IP地址，顺序为：浏览器的缓存、本机host（C:windows/system32/drivers/etc/host	127.0.0.1 localhost 代表本机）、家里局域网的服务器、上级路由、城市的LDNS服务器（local）、继续上级DNS服务器直到GDNS服务器（global）



## 五层网络模型

1. 物理层：将数据转换为可通过物理介质传送的电子信号
2. 数据链路层：MAC地址
3. 网络层：IP地址——IP协议
4. 运输层：TCP协议、UDP协议
5. 应用层：HTTP协议、DNS协议

当与外部服务器进行数据交换时，例如：发送数据需要将数据自上而下包裹各层次协议（物理层（IP协议（TCP协议（HTTP协议 请求头（数据））））），服务器端接受数据则自下而上分解各层次协议而获得数据



## HTTP

### 请求报文

- 格式：请求方式	url	协议及版本	=>	请求行

  ​			键：值									=>	首部行（请求头）

  ​			键=值&键=值						 =>	实体主体（请求体）

- 请求方式有GET/POST（常用）HEAD/PUT/DELETE（不常用）

- 例：GET /path?a=1&b=2 HTTP1.1

  ​		Host: www.baidu.com

  ​		Connection: keep-alive（表示长连接）

  ​		User-Agent: ...

  ​				...

### 数据体（请求体）

- GET方式传输的参数都在url里，信息量不大在几kb左右，数据体基本上没其它信息，所以传输不了大文件

  > HTTP协议理论上GET传输的参数可以不在url中，但现代使用的是基于web环境下的HTTP协议，其要求GET请求的参数都在url里

- POST方式传输的参数都在数据体里，传输大文件优先采用

### 响应报文

- 格式：协议及版本	状态码	短语	=>	状态行

  ​			键：值									  =>	首部行（响应头）
  
  ​			JSON数据								 =>	实体主体（响应体）

- 数据体：



## GET 与 POST 请求方式的区别

### 基于什么前提

#### 无任何前提

不使用任何规范，只考虑语法和理论上的HTTP协议，则GET和POST几乎没有什么区别，只是名字不同

#### 基于RFC规范

- 理论上的（Specification）：GET和POST具有相同语法，但有不同语义。GET用来获取数据，POST用来发送数据，其余方面无差别

- 实现上的（Implementation）：各种浏览器就是这个规范的实现者

   常见的不同：

   - GET的请求数据在URL中是可见的（并不全部显示在地址栏），POST的则不显示在URL中

   - GET对长度有限制，POST长度无限

   - GET请求的数据可被收藏为书签，POST请求的数据则不可被收藏为书签

   - GET请求后，后退、刷新按钮对其数据无影响，POST的数据则会被重新提交

   - GET编码类型：application/x-www-form-url

      POST编码类型：有多种，常用的有：encodeapplication/x-www-form-urlencoded

      ​																multipart/form-data

   - GET历史参数会被保留在浏览器里，POST则不会

   - GET的传送数据只允许ASCII编码，POST则没有编码限制，且允许传送二进制数据

   - GET与POST相比，GET安全性较差（但二者在HTTP协议下都是明文传送），因其所发的数据为URL的一部分



## Cookie & Session

- 保持登录状态如何做到的？

  按照正常的HTTP协议是做不到的，因为HTTP协议是上下文无关协议，所以前端页面上存在可以持久化存储数据的东西，一旦登录之后便会将登录信息存储在其中

### Cookie

- Cookie是存放在浏览器中的，更是存放在不同的域名下的，不能跨域，可以长期存放
- 由Cookie实现的自动登录的过程：
  1. 初始状态：没有登录
  2. 访问百度的登录，键入用户名和密码
  3. 如果用户名和密码正确匹配，则百度的后端会向这个域名下设置一个Cookie，并写入用户的基本信息（加密的）
  4. 之后每一次向百度发送请求，浏览器都会自动带上这些Cookie
  5. 服务器（后端）接收到带有ID的Cookie，就可以解析这个加密过的ID以获取用户本身的ID
  6. 如果能获取到本身的ID，则证明该用户已经登录过，所以后端可以继续保留用户的信息

​		缺点：若浏览器中的Cookie被非法窃取，对方就可以在其电脑上登录用户的账号

### Seesion

- Seesion携带的用户信息存放在服务器端，不易被非法窃取安全性高


- 缺点有：

  1. Seesion需要存放在ram，若用户量级很大，非常消耗服务器的资源
  1. 后端不止一台服务器，但用户信息一般只存在于其执行登录操作的那一台服务器上，且该操作需要通过反向代理（轮询，IP哈希）（IP Hash技术能够将某个IP的请求定向到同一台后端web机器中,这样一来这个IP下的客户端和某个后端web机器就能建立起稳固的session）



## 页面的正确打开方式

- B/S结构	Browser/Server结构——Browser负责内容的展示，Server负责提供内容

- C/S结构    Client/Server结构——Client负责内容的展示，Server负责展示内容

- web页面的本质是一个字符串，带有HTML格式的字符串

- 浏览器向服务器请求一个页面的本质？

  1. 键入url后进行网络请求
  2. 服务器接收到这个请求后，要将该页面的内容（HTML格式的字符串）返回给浏览器
  3. 页面的字符串存储在HTML文件中。例如：xxx.html
  4. 服务器端读取文件
  5. 将读取出来的内容返回给浏览器

  请求所返回的字符串的来源可能是文件，浏览器缓存，数据库

- 服务器：严格意义上服务器是一台提供计算和应用服务的计算机，而我们常说的服务器则是指服务容器

- 服务容器：是一个程序，程序可以监听一个端口（且一个端口仅能被一个程序监听），当用户向服务器发送网络请求时则是由服务容器监听到，然后服务器读取文件然后返回给用户

- 若想要通过访问服务器（服务容器）的方式来访问自己写的网页则要安装一个服务容器的程序



## 发送网络请求

1. 浏览器中直接输入网址
2. location.href="url"，可以发出网络请求，但页面会发生跳转
3. 带有src属性的标签，例如img、script标签。可以发出请求，服务端可处理也可返回，但是返回结果能否被运用取决于浏览器
4. 带有href属性的标签，例如link标签。同上。（src和href属性都是通过get方式发出的请求）
5. 带有action属性的标签，例如form表单。可以发出请求，但页面会发生跳转
6. ajax（Asynchronous Javascript And XML）



## 跨域

### 定义

*同源策略*是浏览器的一种安全策略，所谓同源是指协议、顶级域名、端口完全相同，只有同源的地址才可以相互通过ajax的方式请求，不同源则为跨域请求

### 细节

- 允许被跨域请求的资源：
  - 具有src属性的文件（js文件、图片等）
  - 具有href属性的文件（大部分可以，如css文件等）

- 不允许被跨域请求的资源：
  - 从后端接口请求的数据

  - 其它域的Cookie

  - 其它域的缓存

- 跨域的行为发生在哪？
  - 即使发生了跨域，请求也可正常发出

  - 服务器端可以接受，可以正常处理，可以正常返回数据

  - 浏览器可以接收到返回的数据

  - 接受数据后，辨别出当前页面的域与请求的域不同，则判定为跨域

  - 数据不会再传递给需要执行的代码段

### 解决方案

- 后端配合用户进行跨域
  - JSONP（一般情况下返回的数据都是JSON格式，后端要经过处理将其转换为JSONP格式）
  - 后端设置Access-Control-Allow-Origin属性以支持跨域

- 后端不配合用户进行跨域
  - iframe（只能显示页面，不能通过js来操作）
  - 通过后端代理（用户的后端）



## 跨域的解决方案

### CORS

- 定义：Cross-Origin Resource Sharing 跨域资源共享


- 特点：后端返回的响应头会自动携带 `Access-Control-Allow-Origin`字段

- 实现过程：

  整个 CORS 通信过程，都是浏览器自动完成，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉，只是在被请求的源是否允许指定域请求

- CORS 的两种请求方式：

  - 简单请求

    同时满足以下两条件即属于简单请求:

    1. 请求方法是以下三种方法之一：

       HEAD、GET、POST

    2. HTTP的头信息不超出以下几种字段：

       - Accept
       - Accept-Language
       - Content-Language
       - Last-Event-ID
       - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

  - 非简单请求/复杂请求

    - 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 `PUT` 或 `DELETE`，或者 `Content-Type` 字段的类型是 `application/json`
    - 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求（preflight）
    - 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，返回状态码 204，浏览器才会发出正式的 `XMLHttpRequest` 请求，否则就报错，返回状态码 405



### JSONP

- JSONP 格式：

  进行网络请求时会附带参数 callback，返回的 JSONP 格式则是 `callback名字 + ( + json + )`

- 特点：

  - 只接受 GET 请求的形式

    jsonp 跨域只能使用 get，若设置为 post 则 jQuery 自动更改为 get。而并不是 jsonp 只能使用 get，当jQuery 判断是否同源（即是否跨域）的结果为同源（即非跨域）时，设置为 get/post 即为 get/post，若非同源则设置 get/post 都为 get

  - 需要与后端进行请求参数的约定

  - 有参数数据大小的限制

  - 不是一个真正的 ajax 请求

- JSONP原理

  1. 判断请求与当前页面的域是否同源，若同源则以正常 ajax 形式进行请求

  2. 不同源则生成一个 script 标签，生成一个随机的 callback 名字，且创建一个以此为名的全局函数

  3. 将该 script 标签的 src 属性设置为要请求的接口，且将 callback 作为附带请求参数拼接上

     上述为前端部分

  4. 后端接受到请求后，将要返回的数据用 callback 的值和括号包裹起来（即以 JSONP 的格式封装）

  5. 返回数据

     上述为后端部分

  6. 浏览器接受到数据后将其作为 js 代码执行，即执行一个参数为 json 对象函数名为随机 callback 的函数



### proxy 代理

- 实现：

  本地开启代理服务器，前端代码在代理环境下进行开发，请求由代理服务器进行转发，服务器与服务器之间不涉及到跨域问题

- 常见的代理方式：

  - liveServer：IDE的三方插件
  - webpack devServer：前端工程化构建工具
  - nginx：nginx服务器代理



### iframe 跨域

- postMessage：该方法为 html5 扩展的 API，允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递
- 实现：
  - 父页面向子页面进行数据传递
    1. 父页面找到 iframe 标签，为 ifrme 的 window（通过 iframe.contentWindow 获取）定义绑定postMessage 事件（必须保证页面全部加载完成之后使用该事件，所以应在 iframe.onload 下绑定）
    2. 子页面 window 进行 message 事件的监听，通过回调函数获取父页面传递的信息
  - 子页面向父页面进行数据传递
    1. 子页面获取父页面的 window（通过 window.parent 获取），进行 postMessage 事件注册
    2. 父页面 window 进行 message 事件的监听，通过回调函数获取子页面传递的信息



## TCP

### 定义

TCP协议，即传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议

### 细节

TCP通信需要经过**创建连接、数据传送、终止连接**三个步骤，TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据

### 特点

- 面向连接
- 传输可靠
   - TCP采用发送应答机制
   - 超时重传
   - 错误校验
   - 流量控制和阻塞管理



## 三次握手和四次挥手

### 三次握手

- 不同http版本中三次握手表现

  - http 1.0

    http请求创建的时候同时创建了tcp连接，请求发送，服务器响应之后，tcp连接关闭

  - http 1.1

    通过声明的方式（Keep alive），保持连接（节省tcp连接开销）

  - http 2.0

    http请求可以处理并发,只需要一个tcp连接就可以了

- tcp中的标志位、序列号
  - SYN（synchronous建立联机标志位）
  - ACK（acknowledgement 联机确认标志位）
  - Sequence number（顺序号码，数据包的序号）
  - Acknowledge number（确认号码，响应数据包的序号）
  - FIN（finish结束，终止链路标志位）

- 实现：

  <img src="https://adminimg.hyfarsight.com/v2-576b043d12353928eea6e45373655668_720w.jpg" alt="img" style="zoom: 75%"/>

  1. **第一次握手**：

     客户端协议栈向服务器端发送了 `SYN` 包，并告诉服务器端当前发送序列号 SYN = 1, seq=x，x为本次TCP通信的字节流的初始序号, 客户端进入 SYN_SENT 状态

  2. **第二次握手**：

     服务器端的协议栈收到这个包之后，和客户端进行 `ACK `应答，应答的值为 `x+1`，表示 对 SYN 包 1的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号 为 1，服务器端进入 `SYNC_RCVD` 状态

  3. **第三次握手**：

     客户端协议栈收到 `ACK` 之后，还要向服务端发送一个确认报文段, 表示：服务端发来的连接同意应答已经成功收到，表示客户端到服务器端的单向连接建立成功，客户端发完这个报文段后便进入ESTABLISHED状态，此时连接的建立完成,该报文段的头部为：ACK=1，seq=x+1，ack=y+1, 这个时候服务器端到客户端的单向连接也建立成功，服务端收到这个应答后进入ESTABLISHED状态

  4. 图示：

  <img src="https://adminimg.hyfarsight.com/1643a1dd6df4813b" alt="img" style="zoom: 45%;" />

  <img src="https://adminimg.hyfarsight.com/1643a1f3fa6c21b0" alt="img" style="zoom:45%;" />

- 为什么会有三次握手？

  - 第一种情况：

    若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是“失效的“

  - 第二种情况：

    客户端影响不大，仍然需要获得服务端的应答后才进入ESTABLISHED状态，如果网络拥塞，服务端收到请求才会进入ESTABLISHED状态，此时的客户端早已进入CLOSED状态，服务端一直等待下去



### 四次挥手

- 实现：

  <img src="https://pic1.zhimg.com/80/v2-c8b61ed2a249700583b11bc5d16c5711_720w.jpg?source=1940ef5c" alt="img" style="zoom: 75%;" />

  1. **第一次挥手**：
  
     客户端数据发送完成，需要向服务端发送连接释放请求。请求只有报文头
  
  2. **第二次挥手**：
  
     服务端接收到释放请求，通知相应程序，客户端要进行关闭。此时服务端进入CLOSE-WAIT状态，并向客户端发送连接释放的应答
  
  3. **第三次挥手**：
  
     当服务端向客户端发送完所有数据后，开始向客户端发送连接释放请求，此时服务端进行LAST-ACK状态
  
  4. **第四次挥手**：
  
     客户端接收释放请求后，向服务端发送确认应答，客户端进入TIME-WAIT状态。该状态会持续2MSL时间，服务端没有后续数据发送，进入CLOSED状态，撤销TCB。服务端收到确认应答后，也便进入CLOSED状态，撤销TCB
  
  5. 图示：
  
  <img src="https://adminimg.hyfarsight.com/1643a20296de1ff0" alt="img" style="zoom: 45%;" />
  
  <img src="https://adminimg.hyfarsight.com/1643b1147fbbc5e7" alt="img" style="zoom: 45%;" />



## Web 安全

### 攻击

#### XSS

- 定义：Cross-Site Scripting 跨站脚本攻击
- 成因：主要利用了盲目信任用户的提交内容而没有对其进行安全性处理的缺陷，如：将用户输入的字符串直接转换为 DOM 渲染在页面上
- 特点：
  - 通常难以从 UI 上感知（暗地执行脚本）
  - 窃取用户信息（cookie/token）
  - 绘制 UI（例如弹窗），诱骗用户点击/填写表单
- 类型：
  - *存储型 XSS（Stored XSS）*
    - 恶意脚本被存在数据库中
    - 访问页面 -> 读数据 -> 被攻击
    - 危害最大，对所有用户可见
  - *反射型 XSS（Reflected XSS）*
    - 不涉及数据库
    - 从 URL 上攻击，如：在 URL 的 query 中的 param 注入恶意脚本
  - *基于 DOM 的 XSS （DOM-based XSS）*
    - 不需要服务器的参与
    - 恶意攻击的发起 + 执行，全在浏览器端完成，如：URL 的 param 中的恶意脚本可以在浏览器端直接获取并注入
  - *Mutation-based XSS*
    - 利用浏览器渲染 DOM 的特性（独特优化）
    - 不同浏览器，会有区别（按浏览器进行攻击）

#### CSRF

- 定义：Cross-Site Request Forgery 跨站请求伪造
- 成因：
  - 在用户不知情的情况下
  - 利用用户权限（cookie）
  - 构造指定 HTTP 请求，窃取或修改用户敏感信息
- 特点：大部分是 GET 请求，但也可以利用表单进行 POST 请求

#### SQL 注入

- 定义：SQL Injection
- 成因：通过请求中携带的 SQL 参数恶意注入服务器，使其运行 SQL 命令，对服务器数据进行危险操作
- 例子：读取含有 SQL 参数的请求字段，直接以字符串的形式拼接 SQL 语句
- 注入不止于 SQL，还有
  - CLI
  - OS command


#### SSRF

- 定义：Server-Side Request Forgery 服务端请求伪造
- 特点：严格来说，SSRF 不是注入，但原理类似

#### DoS

- 定义：Denial of Service 拒绝服务
- 成因：通过某种方式（构造特定请求），导致服务器资源被显著消耗，来不及响应更多请求，导致请求挤压，进而雪崩效应。
- 分类：
  - *ReDoS*
    - 基于正则表达式的 DoS
    - 贪婪匹配一个错误的正则表达式，采用回溯策略，造成服务器响应时间上升，接口吞吐量下降
  - *Logical DoS*
    - 耗时的同步操作
    - 数据库写入
    - SQL join
    - 文件备份
    - 循环执行逻辑
  - *Distributed DoS (DDoS)*
    - 短时间内，来自大量僵尸设备的请求流量，服务器不能及时完成全部请求，导致请求堆积，进而雪崩效应，无法响应新请求。
    - 攻击特点：
      - 直接访问 IP
      - 任意 API
      - 消耗大量带宽（耗尽）
    - 例子：SYN Flood：握手未完成，连接不释放，达到最大连接数，拒绝新请求

#### 中间人攻击

利用 HTTP 传输的缺点：
- 明文传输 => 信息窃听
- 无信息完整性校验 => 信息篡改
- 无身份验证 => 信息劫持

### 防御

#### XSS

- 永远不信任用户的提交内容，例如：不要将用户提交内容直接转换成 DOM
- 现成工具：
  - 前端：
    - 主流框架默认防御 XSS
    - google-closure-library
  - 后端（Node）：
    - DOMPurify
- 注意点：
  - string => DOM
  - 上传 SVG
  - Blob 动态生成 script
  - 自定义跳转链接
  - 自定义样式

#### CSRF

- 思路：伪造请求来自异常来源，那么就限制异常来源进而限制伪造请求
- 方案：
  - *请求头部*
    - Origin：同源请求中，GET + HEAD 不发送
    - Referer：
  - *token*
    - 首次请求页面后服务器返回 token，后续请求相关 API 需携带 token 进行验证
    - 注意点：
      - 用户绑定：因为攻击者也可以是注册用户，所以 token 要和用户绑定，避免混淆
      - 过期时间：做到前向保密
  - *X-Frame-Options*
    - DENY / SAMEORIGIN 两配置值
    - 用于防止 iframe 攻击
  - *明确接口职能*
    - 如 GET 和 POST 请求的接口分开实现，不要耦合在一起
    - 防御 CSRF anti-pattern
  - *SameSite Cookie*
    - 避免用户信息被携带
    - 限制的是：
      - Cookie domain
      - 页面域名
    - 依赖 Cookie 的第三方服务可以 Set-Cookie: SameSite=None; Secure;
  - *防御 CSRF 的正确姿势*
    - 因为 CSRF 层出不穷，则使用不同职能的中间件来构建一个防护层效果最好

#### 注入

- 针对 SQL 注入：
  - 找到项目中查询 SQL 的地方
  - 使用 prepared statement
- 非 SQL 注入：
  - 最小权限原则：例如 sudo 和 root 操作坚决不允许
  - 建立允许名单 + 过滤： 避免 rm 等危险操作
  - 对 URL 类型参数进行协议、域名、IP 等限制：防止内网被访问

#### DoS

- Regex DoS：
  - Code Review：拒绝贪婪模式的正则表达式
  - 代码扫描 + 正则性能测试
  - 拒绝用户提供正则
- Logical DoS：
  - 不是非黑即白，有些case，只有在请求量大到一定之后，才会体现
  - 分析代码中的性能瓶颈（与缓存有关？）：
    - 同步调用
    - 串行逻辑
    - CPU密集型操作
  - 限流
- DDoS：
  - 流量治理：
    - 负载均衡（过滤）
    - API网关（过滤）
    - CDN（抗量）
  - 快速自动扩容（抗量）
  - 非核心服务降级（抗量）

#### 中间人

- HTTPS
  - 可靠性：加密
  - 完整性：MAC验证
  - 不可抵赖性：数字签名
- HTTP Strict-Transport-Security (HSTS)
  - 将 HTTP 主动升级到 HTTPS
  - 需要先有一次 HTTPS 访问
- Subresource Integrity (SRI)
  - 静态资源被劫持篡改？ => 对比 hash
  - CDN 常用

#### 补充

- Feature Policy / Permission Policy
  - 一个源（页面）下，可以使用哪些功能
