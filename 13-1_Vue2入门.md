## vue知识体系

- **模板**：
  - *内容*：
    - `mustache`语法
  - *指令*：
    - `v-bind`：
      - 用途：绑定属性
      - 用法：`v-bind:属性名="js表达式"`
      - 简写：`:`
      - 特殊情况：
        - 绑定style时属性值有不同表达形式，如：绑定一个对象等
        - 绑定class时属性值有不同表达形式，如：绑定一个对象、绑定一个字符串、绑定一个数组等
    - `v-for`：（优先级最高，即这些指令同时书写时先执行v-for）
      - 用途：循环数组
      - 用法：`v-for="表达式"`
      - 注意点：注意绑定key值，且保证绑定的key值唯一且稳定
    - `v-on`：
      - 用途：绑定事件
      - 用法：`v-on:事件名="表达式"`
      - 简写：`@`
    - `v-if、v-else、v-else-if`：值为false的时候不生成对应vnode，不生成对应dom，值为true时相反
    - `v-show`：值为false时生成对应vnode，生成对应dom，将其display属性变更为none，值为true时相反
    - `v-slot`：
      - 用途：绑定模板，值为该模板将要传递给子组件对应插槽的插槽名
      - 用法：`v-slot:插槽名`
      - 简写：`#`
    - `v-html`：
    - `v-model`：
    - 自定义指令
  - *特殊属性*：
    - `key`：在循环渲染过程中为了提高渲染效率，给每个渲染元素一个唯一稳定的值‘
    - `ref`：往当前组件的`$refs`属性中加入一个引用
- **配置**：
  - `data`：和界面相关的数据
  - `methods`：任何可能需要调用的方法
  - `template`：配置模板
  - `render`：渲染方法，用于生成vnode
  - `el`：挂载的目标元素
  - `components`：局部注册组件
  - `props`：声明组件的属性。两种声明形式，数组和对象
  - `computed`：计算属性
  - `router`：配置vue路由
  - `mixins`：组件混入的配置
  - `watch`：
  - 生命周期钩子函数：
    - `beforeCreate`
    - `created`
    - `beforeMount`
    - `mounted`
    - `beforeUpdate`
    - `updated`
    - `beforeDestroy`
    - `destroyed`
- **组件通信**：
  - `props`：父组件传递给子组件，子组件没有权力更改
  - `event`：子组件抛出事件到父组件
  - `$refs`：可以获得子组件的实例，对其成员进行操作
  - `router`：通过路由，间接在不同组件之间通信
  - `$listeners`：用于获取父组件中的事件监听器
  - `v-model`：
  - 事件总线：很灵活
  - `vuex`：状态管理模式 + 库
- **实例成员**：
  - `$mount`：将vue实例渲染出的真实dom树挂载到页面的某个元素上
  - `$emit()`：在组件中抛出一个事件
  - `$el`：获得一个组件或者vue实例中渲染的真实dom树的根元素
  - `$refs`：获得当前组件里持有的所有引用，来自于元素的`ref`属性所指定的引用
  - `$listeners`：包含了父作用域中的 `v-on` 事件监听器
  - `$on()`：监听当前实例上的自定义事件
  - `$off()`：移除自定义事件监听器
  - `$slots`：用来访问被[插槽分发](https://cn.vuejs.org/v2/guide/components.html#通过插槽分发内容)的内容
- **内置组件**：
  - `slot`：插槽。用于占位，表示需要父组件传递内容的区域

- **插件**：
  - `vue-router`：
    - 组件：
      - `RouterView`：用于渲染匹配到的组件
      - `RouterLink`：无刷新的导航链接，会根据配置的路由模式切换路径
        - 属性：
          - `to`：导航的目标
          - `exact`：
            - true。表示只有精确匹配到导航路径，才会添加激活类样式
            - false。默认值。只要路径以导航路径开头，就会添加激活类样式

          - `active-class、exact-active-class`：激活类样式名
            - 默认值分别为router-link-active和router-link-exact-active
    - 路由配置：
      - `routes`：配置路由匹配规则
      - `mode`：配置匹配模式
        - hash
        - history
        - abstract
    - 注入的原型对象：
      - `$route`：提供路由信息
      - `$router`：用于控制页面跳转
  - `vuex`：
    - 注入的原型对象：
      - `$store`



## 核心概念

- **注入**：完成数据响应式，并把实现响应式的数据提取到vue实例中去

  <img src="https://camo.githubusercontent.com/c42553c339985ca384d38a295c92aa0e5858ebaad22141e98d80cc8294868b9b/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f32303230313131303136333534382e706e67" style="zoom: 40%">

  - vue会将以下配置注入到vue实例中：
    - data：和界面相关的数据
    - computed：通过已有数据计算得来的数据
    - methods：方法
    - props：属性
  - 注入之后模板中可以使用vue实例中的成员，即开始存在数据响应式，注入之前还没有

- **虚拟DOM树**：

  - 直接操作真实的dom会引发严重的效率问题，vue使用虚拟dom（vnode）的方式来描述要渲染的内容

  - vnode是一个普通的js对象，用于描述界面上应该有什么，例如：

    ```js
    const vnode = {
    	tag: "h1",
        children: [
            { tag: undefined, text: "第一个vue应用：Hello World" }
        ]
    }
    ```

    这个对象即描述了有一个标签名为h1的节点，它有一个子节点，是一个文本节点，内容为“第一个vue应用：Hello World”

  - vue模板并不是真实的dom，它会被编译成虚拟dom：

    ```html
    <div id="app">
    	<h1>第一个vue应用：{{title}}</h1>
        <p>作者：{{author}}</p>
    </div>
    ```

    上面的模板会被编译成类似于下面结构的虚拟dom：

    ```js
    {
      tag: "div",
      children: [
        { tag: "h1", children: [ { text: "第一个vue应用：Hello World" } ] },
        { tag: "p", children: [ { text: "作者：袁" } ] }
      ]
    }
    ```

    虚拟dom树会最终生成真实的dom树：

    <img src="https://camo.githubusercontent.com/916ece5b98badd86c48ffaed850a8879b82569c2b046c18c566317e3b9e12efe/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f32303230313130363134343533362e706e67" style="zoom: 35%">

    当数据变化后，将引发重新渲染，vue会比较新旧两棵vnode tree，找出差异，然后仅把差异部分应用到真实dom tree中：

    <img src="https://camo.githubusercontent.com/a69d2562d008055c2264b36035f5367ad6d513ed86a0de099d8f98aa70ccf0a8/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f32303230313130363134353430392e706e67" style="zoom: 35%">

    可见，在vue中要得到最终的界面，必须要生成一个vnode tree，vue通过以下逻辑生成vnode tree：

    <img src="https://camo.githubusercontent.com/a06739a53292ac2912ff0e1818c4e66af79abe07c2523995cc45fa84f18f7fcf/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f32303230313130363135323034362e706e67" style="zoom: 40%">

    - 从图中可知最终的虚拟节点树是由`render`函数的运行返回结果得到的，而`render`函数若没有自行书写则会去寻找`template`配置，若还没有则去寻找`el`配置
    - `render`函数会传入一个参数`createElement`，返回值为此参数函数的调用结果。`createElement()`的两个参数分别为，要新加的元素的标签名称、该元素的子节点数组
    - 注意：虚拟节点树必须是单根的

- **挂载**：

  - 将生成的真实dom树，放置到某个元素位置，称之为挂载
  - 挂载的方式：
    1. 通过`el:"css选择器"`进行配置
    2. 通过`vue实例.$mount("css选择器")`进行配置

- **完整流程**：

  <img src="https://camo.githubusercontent.com/2cf703e9db28453f6f3ae952b0920040ee31607edc0f8a9f5eb6bbfb419a7082/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f32303230303930383035313933392e706e67" style="zoom: 40%">



## 组件

- 背景：

  - 组件的出现是为了实现以下两个目标：
    1. 降低整体复杂度，提升代码的可读性和可维护性
    2. 提升局部代码的可复用性
  - 绝大部分情况下，一个组件就是页面中某个区域，组件包含该区域的：
    - 功能（JS代码）
    - 内容（模板代码）
    - 样式（CSS代码）要在组件中包含样式，需要构建工具的支撑

- **组件开发**：

  - *创建组件*：

    - 组件是根据一个普通的配置对象创建的，所以要开发一个组件，只需要写一个配置对象即可

    - 该配置对象和vue实例的配置是几乎一样的：

      ```js
      //组件配置对象
      const myComp = {
        data(){
          return {
            // ...
          }
        },
        template: `....`
      }
      ```

      值得注意的是，组件配置对象和vue实例有以下几点差异：

      - 无`el`
      - `data`必须是一个函数，该函数返回的对象作为数据
      - 由于没有`el`配置，组件的虚拟DOM树必须定义在`template`或`render`中

  - *注册组件*：

    - 注册组件分为两种方式，分别为全局注册、局部注册

    - 全局注册：

      - 一旦全局注册了一个组件，整个应用中任何地方都可以使用该组件

        <img src="https://camo.githubusercontent.com/fb08b31db81e626aab473e1c69f15ead30dfb7d62bd09d704f9150d8c69583fc/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f323032302d30322d31382d31302d32342d34342e706e67" style="zoom: 50%">

      - 全局注册的方式是：

        ```js
        // 参数1：组件名称，将来在模板中使用组件时，会使用该名称
        // 参数2：组件配置对象
        // 该代码运行后，即可在模板中使用组件
        Vue.component('my-comp', myComp);
        ```

        在模板中，可以使用组件了

        ```html
        <my-comp />
        <!-- 或 -->
        <my-comp></my-comp>
        ```

      - 但在一些工程化的大型项目中，很多组件都不需要全局使用。 比如一个登录组件，只有在登录的相关页面中使用，如果全局注册，将导致构建工具无法优化打包 因此，除非组件特别通用，否则不建议使用全局注册

    - 局部注册：

      - 局部注册就是哪里要用到组件，就在哪里注册

        <img src="https://camo.githubusercontent.com/ab7dbba235e6b89472e37a878e12719a0524492869f18f8967a0c852c1351423/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f323032302d30322d31382d31302d32382d34352e706e67" style="zoom: 50%">

      - 局部注册的方式是，在要使用组件的组件配置或vue实例配置中加入一个配置：

        ```js
        // 这是另一个要使用my-comp的组件
        const otherComp = {
          components:{
            // 属性名为组件名称，模板中将使用该名称
            // 属性值为组件配置对象
            "my-comp": myComp
          },
          template: `
            <div>
              <!-- 该组件的其它内容 -->
              <my-comp></my-comp>
            </div>
          `;
        }
        ```

  - *应用组件*：

    - 在模板中使用组件特别简单，把组件名（注意不是组件配置对象名）当作HTML元素名使用即可，但要注意以下几点：

      1. 组件必须有结束：

         - 组件可以自结束，也可以用结束标记结束，但必须要有结束

         - 下面的组件使用是错误的：

           ```html
           <my-comp>
           ```

      2. 组件的命名：

         - 无论使用哪种方式注册组件，组件的命名需要遵循规范

         - 组件可以使用`kebab-case 短横线命名法`，也可以使用`PascalCase 大驼峰命名法`，下面两种命名均是可以的：

           ```js
           const otherComp = {
             components:{
               "my-comp": myComp,  // 方式1
               MyComp": myComp //方式2
             }
           }
           ```

         - 实际上，使用`小驼峰命名法 camelCase`也是可以识别的，只不过不符合官方要求的规范

         - 使用`PascalCase`方式命名还有一个额外的好处，即可以在模板中使用两种组件名：

           ```js
           const otherComp = {
             components:{
               MyComp: myComp
             }
           }
           ```

           模板中：

           ```html
           <!-- 可用 -->
           <my-comp />
           <MyComp />
           ```

           因此，在使用组件时，为了方便，往往使用以下代码：

           ```js
           const MyComp = {
             //组件配置
           }
           
           const OtherComp = {
             components:{
               MyComp // ES6速写属性
             }
           }
           ```

- **组件树**：

  - 一个组件创建好后，往往会在各种地方使用它。它可能多次出现在vue实例中，也可能出现在其它组件中，于是就形成了一个组件树

    <img src="https://camo.githubusercontent.com/3c71c5317e6064a0b4799b06a0e018286045feb282f124c6ea25432ab6f7e06e/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f323032302d30322d31382d31312d30302d35382e706e67" style="zoom: 50%">

- **向组件传递数据**：

  - 大部分组件要完成自身的功能，都需要一些额外的信息。比如一个头像组件，需要告诉它头像的地址，这就需要在使用组件时向组件传递数据

  - 传递数据的方式有很多种，最常见的一种是使用**组件属性 component props**

  - 首先在组件中申明可以接收哪些属性：

    ```js
    const MyComp = {
      props:["p1", "p2", "p3"],
      // 和vue实例一样，使用组件时也会创建组件的实例
      // 而组件的属性会被提取到组件实例中，因此可以在模板中使用
      // 组件属性也可以配置成对象形式，例如：
      props: {
          p1: {	// 配置的每个属性又可以再单独做一些配置
              type: Array, // 规定属性类型必须为数组
              default: () => [], // 规定属性默认值，为数组或对象时需要以函数的形式返回
              required: true // 是否一定要传参这个属性，true则为是
          }
      }
      template: `
        <div>
          {{p1}}, {{p2}}, {{p3}}
        </div>
      `
    }
    ```

    在使用组件时，向其传递属性：

    ```js
    const OtherComp = {
      components: {
        MyComp
      },
      data(){
        return {
          a:1
        }
      },
      template: `
        <my-comp v-bind:p1="a" p2="2" p3="3"/>
      `
    }
    ```

  - 注意：在组件中，属性是只读的，绝不可以更改，这叫做单向数据流

    <img src="https://camo.githubusercontent.com/98f0b5aa239e3508b114192cc2e62a73d7f5ace8d7017aff8275aa22b4f77997/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f323032302d30322d31382d31312d31332d31392e706e67" style="zoom: 50%">

- vue-cli脚手架搭建工程时所创建的main.js文件可以这样解析：

  ```js
  import Vue from "vue";
  import App from "./App";
  
  new Vue({
    render: (h) => h(App),
    // 相当于下面语句合起来的效果：
    // components: {
    //     App
    // },
    // template: `<App />`
  }).$mount("#app");
  ```

  - 往render函数中传入的createElement函数中传入的不仅可以是一个html元素，还可以是一个组件对象
  - render函数将其渲染后返回虚拟节点树，此处渲染的是一个虚拟节点，而该节点为一个组件



## 搭建工程

- **vue-cli**：

  - vue-cli是一个脚手架工具，用于搭建vue工程，它内部使用了webpack，并预置了诸多插件（plugin）和加载器（loader），以达到开箱即用的效果
  - 除了基本的插件和加载器外，vue-cli还预置了：
    - babel
    - webpack-dev-server
    - eslint
    - postcss
    - less-loader
    - 其它

- **SFC**：

  - 单文件组件 Single File Component，即一个文件就包含了一个组件所需的全部代码

    ```vue
    <template>
    	<!-- 组件模板代码 -->
    </template>
    
    <script>
    export default {
      // 组件配置
    }
    </script>
    
    <style>
    	/* 组件样式 */
    </style>
    ```

- **预编译**：

  - 当vue-cli进行打包时，会直接把组件中的模板转换为render函数，这叫做模板预编译

  - 这样做的好处在于：

    1. 运行时就不再需要编译模板了，提高了运行效率
    2. 打包结果中不再需要vue的模板编译系统代码，减少了打包体积

  - 也就是说如果将模板在组件配置对象中书写，打包完成之后模板无法被编译成虚拟dom树，因为运行时态已经没有模板编译系统了

    <img src="https://camo.githubusercontent.com/8f3eff95e6b9b78fcde4aa32ae41ffa7a1b29b303e564c6fa7332405667ad523/687474703a2f2f6d6472732e7975616e6a696e2e746563682f696d672f32303230313131313135353631332e706e67" style="zoom: 35%">



## 计算属性

- 面试题：计算属性和方法有什么区别？

  - 计算属性本质上是包含getter和setter的方法
  - 当获取计算属性时，实际上是在调用计算属性的getter方法。vue会收集计算属性的依赖，并缓存计算属性的返回结果。只有当依赖变化后才会重新进行计算。
  - 方法没有缓存，每次调用方法都会导致重新执行。
  - 计算属性的getter和setter参数固定，getter没有参数，setter只有一个参数。而方法的参数不限。
  - 由于有以上的这些区别，因此计算属性通常是根据已有数据得到其它数据，并在得到数据的过程中不建议使用异步、当前时间、随机数等副作用操作。
  - 实际上，它们最重要的区别是含义上的区别。计算属性含义上也是一个数据，可以读取也可以赋值；方法含义上是一个操作，用于处理一些事情。

- 完整的计算属性书写：

  ```js
  computed: {
    propName: {
      get(){
        // getter
      },
      set(val){
        // setter
      }
    }
  }
  ```

  只包含getter的计算属性简写：

  ```js
  computed: {
    propName(){
      // getter
    }
  }
  ```



## 作用域样式对子组件根元素的影响

<img src="https://github.com/DuYi-Edu/DuYi-Vue2/blob/main/1.%20%E5%85%A5%E9%97%A8/06.%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/%E8%AF%BE%E4%BB%B6/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A0%B7%E5%BC%8F%E5%AF%B9%E5%AD%90%E7%BB%84%E4%BB%B6%E6%A0%B9%E5%85%83%E7%B4%A0%E7%9A%84%E5%BD%B1%E5%93%8D.jpg?raw=true" style="zoom: 40%">

- 由图可知子组件根元素的样式不仅收到自身作用域样式的影响，还会受到父组件作用域样式的影响
- 父组件作用域样式也只能影响子组件根元素的样式，其它子元素无法影响



## 组件事件

- 补充：样式中导入文件，路径符号`~@`表示src目录，脚本中导入文件，路径符号`@`表示src目录

- 全局样式：将一些全局通用，各个组件都有可能使用到的样式提取出来单独放在一个样式文件内

- **v-if 和 v-show**：

  - v-if：

    <img src="http://mdrs.yuanjin.tech/img/20201113133827.png" style="zoom: 30%">

  - v-show：

    <img src="http://mdrs.yuanjin.tech/img/20201113134051.png" style="zoom: 30%">

- **面试题：v-if 和 v-show 有什么区别？**

  - v-if能够控制是否生成vnode，也就间接控制了是否生成对应的dom。当v-if为true时，会生成对应的vnode，并生成对应的dom元素；当其为false时，不会生成对应的vnode，自然不会生成任何的dom元素
  - v-show始终会生成vnode，也就间接导致了始终生成dom。它只是控制dom的display属性，当v-show为true时，不做任何处理；当其为false时，生成的dom的display属性为none
  - 使用v-if可以有效的减少树的节点和渲染量，但也会导致树的不稳定；而使用v-show可以保持树的稳定，但不能减少树的节点和渲染量。
  - 因此，在实际开发中，显示状态变化频繁的情况下应该使用v-show，以保持树的稳定；显示状态变化较少时应该使用v-if，以减少树的节点和渲染量

- **组件事件**：

  <img src="http://mdrs.yuanjin.tech/img/20201113134557.png" style="zoom:35%;">

  - 抛出事件：子组件在某个时候发生了一件事，但自身无法处理（基于组件属性传递单项数据流），于是通过事件的方式通知父组件处理

  - 事件参数：子组件抛出事件时，传递给父组件的数据

  - 注册事件：父组件申明，当子组件发生某件事的时候，自身将做出一些处理

    注册事件时书写表达式处可以直接传函数引用，也可以传函数调用（即可以手动传多个参数，事件对象参数为`$event`）




## 插槽

- **插槽的简单用法**：

  - 在某些组件的模板中，有一部分区域需要父组件来指定，例如：

    ```html
    <!-- message组件：一个弹窗消息 -->
    <div class="message-container">
        <div class="content">
        	<!-- 这里是消息内容，可以是一个文本，也可能是一段html，具体是什么不知道，需要父组件指定 -->
        </div>
        <button>确定</button>
        <button>关闭</button>
    </div>
    ```

  - 此时，就需要使用插槽来定制组件的功能：

    ```html
    <!-- message组件：一个弹窗消息 -->
    <div class="message-container">
        <div class="content">
        	<!-- slot是vue的内置组件 -->
        	<slot></slot>
      	</div>
        <button>确定</button>
        <button>关闭</button>
    </div>
    
    <!-- 父组件App -->
    <Message>
        <div class="app-message">
            <p>App Message</p>
        	<a href="">detail</a>
      	</div>
    </Message>
    
    <!-- 最终的结果 -->
    <div class="message-container">
        <div class="content">
            <div class="app-message">
                <p>App Message</p>
                <a href="">detail</a>
            </div>
        </div>
        <button>确定</button>
        <button>关闭</button>
    </div>
    ```

    <img src="http://mdrs.yuanjin.tech/img/20201202152326.png" style="zoom: 35%">

- **具名插槽**：

  - 如果某个组件中需要父组件传递多个区域的内容，也就意味着需要提供多个插槽，为了避免冲突，就需要给不同的插槽赋予不同的名字：

    ```html
    <!-- Layout 组件 -->
    <div class="layout-container">
      <header>
        <!-- 我们希望把页头放这里，提供插槽，名为header -->
        <slot name="header"></slot>
      </header>
      <main>
        <!-- 我们希望把主要内容放这里，提供插槽，名为default -->
        <slot></slot>
      </main>
      <footer>
        <!-- 我们希望把页脚放这里，提供插槽，名为footer -->
        <slot name="footer"></slot>
      </footer>
    </div>
    
    <!-- 父组件App -->
    <BaseLayout>
      <template v-slot:header>
        <h1>Here might be a page title</h1>
      </template>
    
      <template v-slot:default>
        <p>A paragraph for the main content.</p>
        <p>And another one.</p>
      <template v-slot:default>
        
      <template v-slot:footer>
        <p>Here's some contact info</p>
      </template>
    </BaseLayout>
          
    <!-- 未命名的插槽为默认插槽，默认名字为default，父组件往子组件默认插槽传递值时除了上面的用法，还可以简写，即去掉template标签直接书写传递的值 -->
    <!-- v-slot: 的简写为 # -->
    ```

    <img src="http://mdrs.yuanjin.tech/img/20201202153229.png" style="zoom:35%;">



## 路由

- 前言：

  <img src="http://mdrs.yuanjin.tech/img/20201202170037.png" style="zoom:35%;">

  1. 如何根据地址中的路径选择不同的组件？
  2. 将选择的组件放置到哪个位置？
  3. 如何无刷新的切换组件？

- **路由插件**：

  - 安装：

    ```sh
    npm i vue-router
    ```

  - 使用：

    ```js
    import Vue from 'vue';
    import VueRouter from 'vue-router';
    
    // Vue.use(插件)，在Vue中安装插件
    Vue.use(VueRouter);
    
    const router = new VueRouter({
      // 路由配置
    });
    
    new Vue({
      ...,
      router
    });
    ```

- **基本使用**：

  ```js
  // 路由配置
  const router = new VueRouter({
    routes: [ // 路由规则
      // 当匹配到路径 /foo 时，渲染 Foo 组件
      { path: '/foo', component: Foo },
      // 当匹配到路径 /bar 时，渲染 Bar 组件
    	{ path: '/bar', component: Bar }
    ]
  });
  ```

  ```html
  <!-- App.vue -->
  <div class="container">
    <div>
      <!-- 公共区域 -->
    </div>
    <div>
      <!-- 页面区域 -->
      <!-- vue-router 匹配到的组件会渲染到 RouterView 组件标记这里-->
      <RouterView />
    </div>
  </div>
  ```

- **路由模式**：

  - 路由模式决定了：

    1. 路由从哪里获取访问路径
    2. 路由如何改变访问路径

  - `vue-router`提供了三种路由模式：

    1. `hash`：默认值。路由从浏览器地址栏中的hash部分获取路径，改变路径也是改变的hash部分。该模式兼容性最好：

       ```text
       http://localhost:8081/#/blog  -->  /blog
       http://localhost:8081/about#/blog  --> /blog
       ```

    2. `history`：路由从浏览器地址栏的location.pathname中获取路径，改变路径使用的H5的`history api（history.pushState()和history.replaceState()）`。该模式可以让地址栏最友好，但是需要浏览器支持`history api`：

       ```text
       http://localhost:8081/#/blog  -->  /
       http://localhost:8081/about#/blog  --> /about
       http://localhost:8081/blog  --> /blog
       ```

    3. `abstract`：路由从内存中获取路径，改变路径也只是改动内存中的值。这种模式通常应用到非浏览器环境中（移动端应用）

       ```text
       内存： /			-->   /
       内存： /about	--> /about
       内存： /blog	  --> /blog
       ```

- **导航**：

  - `vue-router`提供了全局的组件`RouterLink`，它的渲染结果是一个`a`元素：

    ```html
    <RouterLink to="/blog">文章</RouterLink>
    
    <!-- mode:hash 渲染生成 -->
    <a href="#/blog">文章</a>
    
    <!-- mode:history 渲染生成 -->
    <!-- 为了避免刷新页面，vue-router实际上为它添加了点击事件，并阻止了默认行为，在事件内部使用hitory api更改路径 -->
    <a href="/blog">文章</a>
    ```

  - 首次：

    <img src="http://mdrs.yuanjin.tech/img/20201203150453.png" style="zoom:30%;">

  - 之后：

    <img src="http://mdrs.yuanjin.tech/img/20201203150918.png" alt="image-20201203150918219" style="zoom:30%;">

- **激活状态**：

  - 默认情况下，`vue-router`会用 当前路径 匹配 导航路径 ：

    - 如果当前路径是以导航路径开头，则算作匹配，会为导航的a元素添加类名`router-link-active`
    - 如果当前路径完全等于导航路径，则算作精确匹配，会为导航的a元素添加类名`router-link-exact-active`

  - 例如，当前访问的路径是 /blog ，则：

    | 导航路径 | 类名                                          |
    | -------- | --------------------------------------------- |
    | /        | router-link-active                            |
    | /blog    | router-link-active   router-link-exact-active |
    | /about   | 无                                            |
    | /message | 无                                            |

  - 可以为组件`RouterLink`添加boolean属性`exact`，将匹配规则改为：必须要精确匹配才能添加匹配类名`router-link-active`，例如，当前访问的路径是 /blog ，则：

    | 导航路径 | exact | 类名                                          |
    | :------- | ----- | --------------------------------------------- |
    | /        | true  | 无                                            |
    | /blog    | false | router-link-active   router-link-exact-active |
    | /about   | true  | 无                                            |
    | /message | true  | 无                                            |

    例如，当前访问的路径是 /blog/detail/123 ，则：

    | 导航路径 | exact | 类名               |
    | -------- | ----- | ------------------ |
    | /        | true  | 无                 |
    | /blog    | false | router-link-active |
    | /about   | true  | 无                 |
    | /message | true  | 无                 |

    exact的写法有 `exact` 和 `:exact="true"` 两种，都表示exact的状态为true，第一种不写则为false，对应第二种则赋值false

  - 另外，可以通过`active-class`属性更改匹配的类名，通过`exact-active-class`更改精确匹配的类名

- **命名路由**：

  使用命名路由可以解除系统与路径之间的耦合：

  ```js
  // 路由配置
  const router = new VueRouter({
    routes: [ // 路由规则
      // 当匹配到路径 /foo 时，渲染 Foo 组件
      { name:"foo", path: '/foo', component: Foo },
      // 当匹配到路径 /bar 时，渲染 Bar 组件
    	{ name:"bar", path: '/bar', component: Bar }
    ]
  });
  
  // 项目中使用到这个路径的地方我们采用传递路由信息对象的方式，这样当我们需要改动某个匹配规则的路径时，直接在规则对象中修改便可，项目中的其它位置使用到这个路径的地方无需再修改
  ```

  ```html
  <!-- 向to属性传递路由信息对象 RouterLink会根据你传递的信息以及路由配置生成对应的路径 -->
  <RouterLink :to="{ name:'foo' }">go to foo</RouterLink>
  ```

  

## css module

- **使用css module**：
  - 有时要在js中直接生成dom加入页面中或其它需求，且要动态给元素赋予样式类名，为了防止与组件中书写的样式或其它全局样式中的类名发生重复，则可以使用css module
  - 用法：将样式文件命名为 `xxx.module.ooo` ，`xxx` 为文件名，`ooo` 为样式文件后缀名，可以是css、less、sass等，例如 `demo.module.less`
  - 如此做vue-cli就会在内部通过webpack启用css module



## 得到组件渲染的DOM、拓展vue实例

- **得到组件渲染的DOM**：

  ```js
  /* 获得某个组件渲染的DOM根元素 */
  function getComponentRootDom(comp, props) {
      const vm = new Vue({
          render: (h) => h(comp, {props})
      });
      vm.$mount();
      return vm.$el;
  }
  ```

- **拓展vue实例**：

  ```js
  Vue.prototype = ....;	// 即在Vue的实例上添加成员
  ```

  <img src="http://mdrs.yuanjin.tech/img/20201203172154.jpg" style="zoom: 33%">



## ref

- `ref`往当前组件的`$refs`属性中加入一个引用，`$refs`获得当前组件里持有的所有引用，`ref`标记的元素要等到生成真实dom并挂载后才能通过`$refs`获取到

- 通过`ref`可以直接操作dom元素，甚至可能直接改动子组件，这些都不符合vue的设计理念，除非迫不得已，否则不要使用`ref`

  ```vue
  <template>
  	<div>
      	<p ref="para">some paragraph</p>
      	<ChildComp ref="comp" />
      	<button @click="handleClick">查看所有引用</button>
    	</div>
  </template>
  
  <script>
    	import ChildComp from "./ChildComp"
  	export default {
      components:{
        ChildComp
      },
      methods:{
        handleClick(){
          // 获取持有的所有引用
          console.log(this.$refs);
          /*
          {
          	para: p元素（原生DOM）,
          	comp: ChildComp的组件实例
          }
          */
        }
      }
    }
  </script>
  ```



## 远程获取数据

- **远程获取数据的意义**：

  <img src="http://mdrs.yuanjin.tech/img/20201204145137.png" style="zoom:35%;" />

- **开发环境有跨域问题**：

  ```mermaid
  sequenceDiagram
  浏览器->>前端开发服务器: http://localhost:8080/
  前端开发服务器->>浏览器: 页面
  浏览器->>后端测试服务器: ajax 跨域：http://test-data:3000/api/news
  后端测试服务器->>浏览器: JSON数据
  rect rgb(224,74,74)
  Note right of 浏览器: 浏览器阻止数据移交
  end
  ```

- **生产环境没有跨域问题**：

  - 情况一：

    ```mermaid
    sequenceDiagram
    浏览器->>服务器: http://www.my-site.com/
    服务器->>浏览器: 页面
    浏览器->>服务器: ajax：http://www.my-site.com/api/news
    服务器->>浏览器: JSON数据
    ```

  - 情况二：

    ```mermaid
    sequenceDiagram
    浏览器->>静态资源服务器: http://www.my-site.com/
    静态资源服务器->>浏览器: 页面
    浏览器->>数据服务器: ajax 跨域：http://api.my-site.com/api/news
    数据服务器->>浏览器: [允许www.my-site.com]JSON数据
    ```

- **解决开发环境的跨域问题**：

  ```mermaid
  sequenceDiagram
  浏览器->>前端开发服务器: http://localhost:8080/
  前端开发服务器->>浏览器: 页面
  浏览器->>前端开发服务器: ajax：http://localhost:8080/api/news
  前端开发服务器->>后端测试服务器: 代理请求：http://test-data:3000/api/news
  后端测试服务器->>前端开发服务器: JSON数据
  前端开发服务器->>浏览器: JSON数据
  ```

- **为什么要Mock数据**：

  - 原因：

    ```mermaid
    sequenceDiagram
    浏览器->>前端开发服务器: http://localhost:8080/
    前端开发服务器->>浏览器: 页面
    浏览器->>前端开发服务器: ajax：http://localhost:8080/api/news
    前端开发服务器->>后端测试服务器: 代理请求：http://test-data:3000/api/news
    后端测试服务器->>前端开发服务器: 404 （后端正在开发中）
    前端开发服务器->>浏览器: 404
    ```

  - mock结果：

    ```mermaid
    sequenceDiagram
    participant 浏览器
    participant MockJS
    participant 前端开发服务器
    activate MockJS
    Note left of MockJS: 定义ajax拦截规则
    deactivate MockJS
    浏览器->>前端开发服务器: http://localhost:8080/
    前端开发服务器->>浏览器: 页面
    浏览器->>MockJS: ajax：http://localhost:8080/api/news
    MockJS->>浏览器: 模拟的JSON数据
    ```



## 组件生命周期

- **组件生命周期**：

  <img src="http://mdrs.yuanjin.tech/img/20200908051939.png" style="zoom:42%;">

  <img src="http://mdrs.yuanjin.tech/img/20201206132819.png" style="zoom:40%;">

- **常见应用**：

  不要死记硬背，对于具体的情况要灵活处理

  - 加载远程数据（异步数据）：

    ```js
    export default {
        data() {
            return {
                news: []
            }
        },
        async created() {
            this.news = await getNews();
        }
    }
    ```

  - 直接操作DOM：

    ```js
    export default {
        data() {
            return {
                containerHeight: 0,
                containerWidth: 0
            }
        },
        mounted() {
            this.containerHeight = this.$refs.container.clientHeight;
            this.containerWidth = this.$refs.container.clientWidth;
        }
    }
    ```

  - 启动和清除计时器：

    ```js
    export default {
        data() {
            return {
                timer: null
            }
        },
        created() {
            this.timer = setInterval(() => {
                ...
            }, 1000)
        },
    	destroyed() {
    		clearInterval(this.timer)
    	}
    }
    ```




## 自定义指令

- **全局定义**：

  ```js
  // 指令名称为：mydirec1
  Vue.directive('mydirec1', {
    // 指令配置
  })
  
  // 指令名称为：mydirec2
  Vue.directive('mydirec2', {
    // 指令配置
  })
  ```

  定义之后，所有的组件均可以使用`mydirect1`和`mydirect2`指令：

  ```vue
  <template>
    <!-- 某个组件代码 -->
    <div>
      <MyComp v-mydirec1="js表达式" />
      <div v-mydirec2="js表达式">
        ...
      </div>
      <img v-mydirec1="js表达式" />
    </div>
  </template>
  ```

- **局部定义**：

  - 局部定义是指在某个组件中定义指令，和局部注册组件类似，定义的指令仅在该组件中有效

    ```vue
    <template>
      <!-- 某个组件代码 -->
      <div>
        <MyComp v-mydirec1="js表达式" />
        <div v-mydirec2="js表达式">
          ...
        </div>
        <img v-mydirec1="js表达式" />
      </div>
    </template>
    
    <script>
    export default {
      // 定义指令
      directives: {
        // 指令名称：mydirec1
        mydirec1: {
          // 指令配置
        },
        // 指令名称：mydirec2
        mydirec2: {
          // 指令配置
        }
      }
    }
    </script>
    ```

  - 和局部注册组件一样，为了让指令更加通用，通常我们会把指令的配置提取到其它模块：

    ```vue
    <template>
      <!-- 某个组件代码 -->
      <div>
        <MyComp v-mydirec1="js表达式" />
        <div v-mydirec2="js表达式">
          ...
        </div>
        <img v-mydirec1="js表达式" />
      </div>
    </template>
    
    <script>
      // 导入当前组件需要用到的指令配置对象
      import mydirec1 from "@/directives/mydirec1";
      import mydirec2 from "@/directives/mydirec2";
    	export default {
        // 定义指令
        directives: {
          mydirec1,
          mydirec2
        }
      }
    </script>
    ```

- **指令配置对象**：

  - 没有配置的指令，就像没有配置的组件一样，毫无意义

  - vue支持在指令中配置一些*钩子函数*，在适当的时机，vue会调用这些*钩子函数*并传入适当的参数，以便开发者完成自己想做的事情

  - 常用的钩子函数：

    ```js
    // 指令配置对象
    {
      bind(){
        // 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置
      },
      inserted(){
        // 被绑定元素插入父节点时调用
      },
      update(){
        // 所在组件的 VNode 更新时调用
      }
    }
    ```

    [更多的钩子函数](https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数)

  - 每个钩子函数在调用时，vue都会向其传递四个参数，其中最重要的是前两个参数：

    ```js
    // 指令配置对象
    {
      bind(el, binding){
        // el 是被绑定元素对应的真实DOM
        // binding 是一个对象，描述了指令中提供的信息
      }
    }
    ```

  - binding对象：

    <img src="http://mdrs.yuanjin.tech/img/20210104174229.png" alt="image-20210104174229660" style="zoom:40%;" />

- **配置简化**：

  - 大多数时候，在配置自定义指令时，一般会配置bind和update这两个钩子函数：

    ```js
    {
      bind(el, bingding){
          ...
      },
      update(el, bingding){
          ...
      }
    }
    ```

    这样，在元素绑定和更新时，都能运行到钩子函数

  - 如果这两个钩子函数实现的功能相同，vue提供可以直接把指令配置简化为一个单独的函数的方式：

    ```js
    function(el, bingding){
      // 该函数会被同时设置到bind和update中
    }
    ```

    

## 组件混入

有的时候，许多组件有着类似的功能，这些功能代码分散在组件不同的配置中，如下：

<img src="http://mdrs.yuanjin.tech/img/20210105161811.png" style="zoom: 40%">

于是，我们可以把这些配置代码抽离出来，利用混入融合到组件中：

<img src="http://mdrs.yuanjin.tech/img/20210105162109.png" style="zoom: 40%">

具体做法如下：

```js
// 抽离的公共代码，除了对象的写法，还可以书写成函数的形式（返回值即对象，这样就允许传参）
const common = {
  data(){
    return {
      a: 1,
      b: 2
    }
  },
  created(){
    console.log("common created");
  },
  computed:{
    sum(){
      return this.a + this.b;
    }
  }
}

/**
 * 使用comp1，将会得到：
 * common created
 * comp1 created 1 2 3
 */
const comp1 = {
  mixins: [common] // 之所以是数组，是因为可以混入多个配置代码
  created(){
    console.log("comp1 created", this.a, this.b, this.sum);
  }
}
```



## 组件递归

有时需要在组件中继续调用组件，则可以：

```vue
<template>
  <!-- HierarchyList组件 -->
  <ul class="hierarchy-list-container">
    <li v-for="(item, i) in lists" :key="i">
      <span @click="handleClick(item)">{{ item.name }}</span>
      <HierarchyList :lists="item.children" @select="handleClick" />
    </li>
  </ul>
</template>

<script>
export default {
  name: "HierarchyList", // 要在组件配置给予组件名字，不然在组件定义页递归调用组件自身会显示找不到
  props: {
    lists: {
      type: Array,
      default: () => [],
    },
  },
  methods: {
    // 组件注册的事件处理函数，递归调用的组件应像父组件调用子组件一样也要注册相应的事件
    handleClick(item) {
      this.$emit("select", item);
    },
  },
};
</script>
```



## 动态路由、编程式导航

- **动态路由**：

  - 背景：

    - 我们希望下面的地址都能够匹配到`Blog`组件

      - `/article`，显示全部文章
      - `/article/cate/1`，显示分类`id`为`1`的文章
      - `/article/cate/3`，显示分类`id`为`3`的文章
      - ...

    - 第一种情况很简单，只需要将一个固定的地址匹配到`Blog`组件即可：

      ```js
      {
        path: "/article",
        name: "Blog",
        component: Blog
      }
      ```

    - 但后面的情况则不同，匹配到`Blog`组件的地址中，有一部分是动态变化的，则需要使用一种特殊的表达方式：

      ```js
      {
        path: "/article/cate/:categoryId",
        name: "CategoryBlog",
        component: Blog
      }
      ```

    - 在地址中使用`:xxx`，来表达这一部分的内容是变化的，在`vue-router`中，将变化的这一部分称之为`params`，可以在vue组件中通过`this.$route.params`来获取：

      ```js
      // 访问 /article/cate/3
      this.$route.params // { categoryId: "3" }
      // 访问 /article/cate/1
      this.$route.params // { categoryId: "1" }
      ```

- **动态路由的导航**：

  ```vue
  <router-link to="/article/cate/3">to article of category 3</router-link>
  
  <router-link 
     :to="{
     		name: 'CategoryBlog',
     		params: {
         		categoryId: 3           
     		}                    
     }"
  >to article of category 3</router-link>
  ```

- **编程式导航**：

  除了使用`<RouterLink>`超链接导航外，`vue-router`还允许在代码中跳转页面，通过`$router.push()`：

  ```js
  this.$router.push("跳转地址"); // 普通跳转
  this.$router.push({ // 命名路由跳转
    name:"Blog"
  })
  
  this.$router.go(-1); // 回退。类似于 history.go
  ```

  

## watch

- 利用`watch`配置，可以直接观察某个数据的变化，变化时可以做一些处理：

  ```js
  export default {
    // ... 其它配置
    watch: {
      // 观察 this.$route 的变化，变化后，会调用该函数
      // this.$route 发生变化时是产生一个新的 $route 对象
      $route(newVal, oldVal){
        // newVal：this.$route 新的值，等同 this.$route
        // oldVal：this.$route 旧的值
      },
      // 完整写法
      $route: {
        handler(newVal, oldVal){},
        deep: false, // 是否监听该数据内部属性的变化，默认 false
        immediate: false // 是否立即执行一次 handler，默认 false
      }
      // 观察 this.$route.params 的变化，变化后，会调用该函数
      ["$route.params"](newVal, oldVal){
        // newVal：this.$route.params 新的值，等同 this.$route.params
        // oldVal：this.$route.params 旧的值
      },
    	// 完整写法
      ["$route.params"]: {
        handler(newVal, oldVal){},
        deep: false, // 是否监听该数据内部属性的变化，默认 false
        immediate: false // 是否立即执行一次 handler，默认 false
      }
    }
  }
  ```

  

## $listeners

- `$listeners`是vue的一个实例属性，它用于获取父组件传过来的所有事件函数：

  ```vue
  <!-- 父组件 -->
  <Child @event1="handleEvent1" @event2="handleEvent2" />
  ```

  ```js
  // 子组件
  this.$listeners // { event1: handleEvent1, event2: handleEvent2 } 实际不是这样的对象，但本质差不多
  ```

- `$emit`和`$listeners`通信的异同：

  - 相同点：均可实现子组件向父组件传递消息
  - 差异点：
    - `$emit`更加符合单向数据流，子组件仅发出通知，由父组件监听做出改变；而`$listeners`则是在子组件中直接使用了父组件的方法
    - vue调试工具可以监听到子组件`$emit`的事件，但无法监听到`$listeners`中的方法调用。因为一个是发生事件，另一个只是普通函数的调用
    - 由于`$listeners`中可以获得传递过来的方法，因此调用方法可以得到其返回值。但`$emit`仅仅是向父组件发出通知，无法知晓父组件处理的结果

- 子组件中使用 `v-on="$listeners"` 可以获得父组件所有注册的事件处理函数

- 这样便可处理下面这个问题：子组件中的某项数据在向父组件抛出数据后需要父组件的处理之后才能在子组件中使用，此时该如何解决：

  ```vue
  // 子组件：
  <template>
    <div>
      <button @click="handleClick" :disabled="isLoading">
        {{ isLoading ? "loading" : "submit" }}
      </button>
      <div class="err">{{ error }}</div>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        count: 0, // 点击的次数
        isLoading: false,
        error: "",
      };
    },
    methods: {
      handleClick() {
        /*
         * 点击次数 +1
         * 错误消息清空
         * 为了防止重复点击，需要先将 isLoading 设置为 true
         * 通知父组件：「我被点击了」，并传递当前的点击次数
         * 等待父组件处理（有可能是异步的），将父组件处理的结果设置到 error
         */
        }
      },
    },
  };
  </script>
  
  // 父组件：
  <template>
    <LoadingButton @click="handleClick" />
  </template>
  
  <script>
  import LoadingButton from "./LoadingButton";
  export default {
    components: {
      LoadingButton,
    },
    methods: {
      handleClick(count, callback) {},
    },
  };
  </script>
  ```

  *处理方式一*：（子组件抛出事件时传递一个回调函数作为参数）

  ```vue
  // 子组件：
  <script>
  export default {
    data() {
      return {
        count: 0, // 点击的次数
        isLoading: false,
        error: "",
      };
    },
    methods: {
      handleClick() {
        this.count++;
        this.error = "";
        this.isLoading = true;
        this.$emit("click", this.count, (err) => {
          // 该函数传给父组件，让父组件决定什么时候执行
          this.isLoading = false;
          this.error = err;
        });
      },
    },
  };
  </script>
  
  // 父组件：
  <script>
  import LoadingButton from "./LoadingButton";
  export default {
    components: {
      LoadingButton,
    },
    methods: {
      handleClick(count, callback) {
        setTimeout(() => {
          // ...
          // 处理完成
          callback("请填写账号");
        }, 3000);
      },
    },
  };
  ```

  *处理方式二*：（子组件利用`$listeners`获取到父组件为处理子组件抛出事件的对应事件处理函数，直接在子组件内调用该函数）

  ```vue
  // 子组件：
  <script>
  export default {
    data() {
      return {
        count: 0, // 点击的次数
        isLoading: false,
        error: "",
      };
    },
    methods: {
      async handleClick() {
        this.count++;
        this.error = "";
        this.isLoading = true;
        if (this.$listeners.click) {
          // 判断父组件是否传递了事件处理函数 click
          const err = await this.$listeners.click(this.count);
          this.isLoading = false;
          this.error = err;
        }
      },
    },
  };
      
  // 父组件：
  <script>
  import LoadingButton from "./LoadingButton";
  export default {
    components: {
      LoadingButton,
    },
    methods: {
      async handleClick(count) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve("有一个未知错误");
          }, 3000);
        });
      },
    },
  };
  </script>
  ```

  *处理方式三*：（父组件将对应处理函数当作子组件的属性参数传入，子组件在内部直接调用该属性函数，处理过程类似于方式二）

  ```vue
  // 子组件：
  <script>
  export default {
    props: {
      click: Function,
    },
    data() {
      return {
        count: 0, // 点击的次数
        isLoading: false,
        error: "",
      };
    },
    methods: {
      async handleClick() {
        this.count++;
        this.error = "";
        this.isLoading = true;
        if (this.click) {
          const err = await this.click(this.count);
          this.isLoading = false;
          this.error = err;
        }
      },
    },
  };
  </script>
  
  // 父组件：
  <template>
    <LoadingButton :click="handleClick" />
  </template>
  
  <script>
  import LoadingButton from "./LoadingButton";
  export default {
    components: {
      LoadingButton,
    },
    methods: {
      async handleClick(count) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve("有一个未知错误");
          }, 3000);
        });
      },
    },
  };
  </script>
  ```
  
  

## v-model

- `v-model` 指令用于在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素

- `v-model`本质上只是一个语法糖，例如：

  ```vue
  // 在此情况下，v-model是value属性和input事件的结合体
  <input :value="data" @input="data=$event.target.value" />
  <!-- 等同于 -->
  <input v-model="data" />
  ```

- 具体细节参阅文档：[表单输入绑定](https://cn.vuejs.org/v2/guide/forms.html)



## 事件修饰符

- 针对dom节点的原生事件，vue支持多种修饰符以简化代码

- 修饰符是由点开头的指令后缀来表示的，例如：

  ```html
  <!-- 阻止单击事件继续传播 -->
  <a v-on:click.stop="doThis"></a>
  
  <!-- 提交事件不再重载页面 -->
  <form v-on:submit.prevent="onSubmit"></form>
  ```

- 具体查阅文档：[事件修饰符](https://cn.vuejs.org/v2/guide/events.html#事件修饰符)



## 数据共享

- **背景**：

  - 在vue中遇到*共享数据*，会带来下面的多个问题：

    - 如何保证数据的唯一性？
      - 如果数据不唯一，则会浪费大量的内存资源，降低运行效率
      - 如果数据不唯一，就可能出现不统一的数据，难以维护
    - 某个组件改动数据后，如何让其它用到该数据的组件知道数据变化了？
      - 事件总线貌似可以解决该问题，但需要在组件中手动的维护监听，极其不方便，而且事件总线的目的在于「通知」，而不是「共享数据」

    <img src="http://mdrs.yuanjin.tech/img/20210126132906.png" style="zoom: 35%">

  - 一种比较容易想到的方案，就是把所有的共享数据*全部*提升到根组件，然后通过属性不断下发，当某个组件需要修改数据时，又不断向上抛出事件，直到根组件完成对数据的修改

    <img src="http://mdrs.yuanjin.tech/img/20210126133905.png" style="zoom: 35%">

    - 这种方案的缺陷也非常明显：
      - 需要编写大量的代码层层下发数据，很多组件被迫拥有了自己根本不需要的数据
      - 需要编写大量的代码层层上抛事件，很多组件被迫注册了自己根本处理不了的事件

  - 基于上面的问题，我们可以简单的设置一个*独立的数据仓库*

    <img src="http://mdrs.yuanjin.tech/img/20210126140353.png" style="zoom: 35%">

    - 组件需要什么共享数据，可以自由的从仓库中获取，需要什么拿什么
    - 组件可以自由的改变仓库中的数据，仓库的数据变化后，会自动通知用到对应数据的组件进行更新，实现数据响应式

  - 要实现这一切，可以选择`vuex`

- **创建仓库**：

  - 安装`vuex`后，可以通过下面的方式创建一个数据仓库，在大部分情况下，一个工程仅需创建一个数据仓库：

    ```js
    // store.js
    import Vuex from "vue";
    import Vue from "vue";
    
    Vue.use(Vuex); // 应用vuex插件
    const store = new Vuex.Store({
      // 仓库的配置
      state: { // 仓库的初始状态（数据）
        count: 0
      }
    });
    
    export default store;
    ```

  - 仓库创建好后，你可以使用`store.state`来访问仓库中的数据

  - 如果希望在vue中方便的使用仓库数据，需要将`vuex`作为插件安装：

    ```js
    // main.js
    import Vue from "vue";
    import App from "./App.vue";
    import store from "./store.js";
    
    new Vue({
      store, // 向vue中注入仓库
      render: h => h(App)
    }).$mount("#app");
    ```

  - 之后，在vue组件中，可以通过实例的`$store`属性访问到仓库

  - `Vuex`会自动将配置的状态数据设置为响应式数据，当数据变化时，依赖该数据的组件会自动渲染

- **数据的变更**：

  - 尽管可以利用数据响应式的特点直接变更数据，但这样的做法在大型项目中会遇到问题。因为如果有一天，你发现某个共享数据是错误的，而有一百多个组件都有可能变更过这块数据，你该如何知道是哪一步数据变更出现了问题？

  - 为了能够更好的跟踪数据的变化，`vuex`强烈建议使用`mutation`来更改数据：

    ```js
    const store = new Vuex({
      // 仓库的配置
      state: { // 仓库的初始状态（数据）
        count: 0
      },
      mutations: {
        /**
         * 每个mutation是一个方法，它描述了数据在某种场景下的变化
         * increase mutation描述了数据在增加时应该发生的变化
         * 参数state为当前的仓库数据，会自动传入
         */
        increase(state){
          state.count++;
        },
        decrease(state){
          state.count--;
        },
        /**
         * 求n次幂
         * 该mutation需要一个额外的参数来提供指数
         * 我们把让数据产生变化时的附加信息称之为负荷（负载） payload
         * payload可以是任何类型，数字、字符串、对象均可
         * 在该mutation中，我们约定payload为一个数字，表示指数
         */
        power(state, payload){
          state.count **= payload;
        }
      }
    });
    ```

  - 当我们有了`mutation`后，就不应该直接去改动仓库的数据，而是通过`store.commit`方法提交一个`mutation`，具体做法如下：

    ```js
    // 在vue组件中
    [this.]$store.commit("mutation的名字", payload);
    ```

    并且，如此做之后我们可以通过`vue devtools`观测到数据的变化

  - *特别注意*：

    1. `mutation`中不得出现异步操作。在实际开发的规范中，甚至要求不得有副作用操作，包括：

       - 异步
       - 更改或读取外部环境的信息，例如*localStorage*、*location*、*DOM*等

    2. 提交`mutation`是数据改变的*唯一原因*：

       <img src="http://mdrs.yuanjin.tech/img/20210129151639.png" style="zoom: 40%">

- **异步处理**：

  - 如果在`vuex`中要进行异步操作，需要使用`actions`：

    ```js
    const store = new Vuex({
      state: { 
        count: 0
      },
      mutations: {
        increase(state){
          state.count++;
        },
        decrease(state){
          state.count--;
        },
        power(state, payload){
          state.count **= payload;
        }
      },
      actions: {
        /**
         * context: store上下文对象。一个与store实例具有相同方法和属性的对象，但不是store实例本身
         * payload: 本次异步操作的额外信息
         */
        asyncPower(context, payload){
          setTimeout(function(){
            context.commit("power", payload)
          }, 1000)
        }
      }
    });
    ```

  - 通过`store.dispatch`方法分发一个`action`，具体做法如下：

    ```js
    store.dispatch("action的名字", payload);
    ```

  - 流程：

    <img src="http://mdrs.yuanjin.tech/img/20210129160320.png" style="zoom: 40%">



## vuex经典案例

- 路由总体示意图：

  <img src="http://mdrs.yuanjin.tech/img/20210130141626.png" style="zoom: 40%">

- 鉴权守卫逻辑示意图：

  <img src="http://mdrs.yuanjin.tech/img/20210130144001.png" style="zoom: 40%">

- **vue**：
  
  - [watch配置](https://v2.vuejs.org/v2/api/index.html?redirect=true#watch)
  - [Vue.prototype.$watch](https://v2.vuejs.org/v2/api/index.html?redirect=true#vm-watch)
  
- **vuex**：
  - [mapState](https://v3.vuex.vuejs.org/guide/state.html#the-mapstate-helper)
  - [getters](https://v3.vuex.vuejs.org/guide/getters.html#property-style-access)
  - [mapGetters](https://v3.vuex.vuejs.org/guide/getters.html#the-mapgetters-helper)
  - [modules](https://v3.vuex.vuejs.org/guide/modules.html#module-local-state)
  - [watch](https://v3.vuex.vuejs.org/api/#watch)

- **router**：

  - [exact-path](https://v3.router.vuejs.org/api/#exact-path)
  - [导航守卫](https://v3.router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards)
  



## 打包结果分析

- **分析打包结果**：

  - 由于`vue-cli`是利用webpack进行打包，我们仅需加入一个webpack插件`webpack-bundle-analyzer`即可分析打包结果：

    ```js
    const BundleAnalyzerPlugin = require("webpack-bundle-analyzer")
        .BundleAnalyzerPlugin;
    
    // vue.config.js
    module.exports = {
      // 通过 configureWebpack 选项，可对 webpack 进行额外的配置
      // 该配置最终会和 vue-cli 的默认配置进行合并（webpack-merge）
      configureWebpack: {
        plugins: [new BundleAnalyzerPlugin()]
      },
    };
    ```

  - 为了避免在开发环境中启动`webpack-bundle-analyzer`，我们可以如此做：

    ```js
    // webpack.config.js
    const BundleAnalyzerPlugin = require("webpack-bundle-analyzer").BundleAnalyzerPlugin;
    
    // 判断当前node的执行环境是生产环境还是开发环境
    if (process.env.NODE_ENV === "production") {
      module.exports = {
        plugins: [new BundleAnalyzerPlugin()],
      }
    } else {
      module.exports = {}
    }
    
    // vue.config.js
    module.exports = {
      configureWebpack: require("./webpack.config.js")
    };
    ```

- **优化公共库打包体积**：

  - *使用CDN*：

    - CDN全称为Content Delivery Network，称之为内容分发网络

    - 它的基本原理是：架设多台服务器，这些服务器定期从源站拿取资源保存本地，到让不同地域的用户能够通过访问最近的服务器获得资源

      <img src="http://mdrs.yuanjin.tech/img/20210203133956.png" style="zoom: 40%">

    - 我们可以把项目中的所有静态资源都放到CDN上（收费），也可以利用现成免费的CDN获取公共库的资源

      <img src="http://mdrs.yuanjin.tech/img/20210203140030.png" style="zoom:40%;">

    - 首先，需要在webpack中配置`external`字段不要对公共库进行打包：

      ```js
      // vue.config.js
      module.exports = {
        externals: {
          vue: "Vue",
          vuex: "Vuex",
          "vue-router": "VueRouter",
        }
      };
      ```

    - 然后，在页面中手动加入`cdn`链接：

      ```html
      <body>
        <div id="app"></div>
        <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js"></script>
        <script src="https://cdn.bootcdn.net/ajax/libs/vuex/3.5.1/vuex.min.js"></script>
        <script src="https://cdn.bootcdn.net/ajax/libs/vue-router/3.4.7/vue-router.min.js"></script>
        <!-- built files will be auto injected -->
      </body>
      ```

    - 对于`vuex`和`vue-router`，使用这种传统的方式引入的话其会自动成为Vue的插件，因此需要去掉`Vue.use(xxx)`这种注册插件的方式：

      ```js
      // store.js
      import Vue from "vue";
      import Vuex from "vuex";
      
      // 若是用CDN引入相关模块则会在全局暴露一个变量，因此可以用来判断是否是CDN引入方式
      if(!window.Vuex){
        // 没有使用传统的方式引入Vuex
        Vue.use(Vuex);
      }
      
      // router.js
      import VueRouter from "vue-router";
      import Vue from "vue";
      
      if(!window.VueRouter){
        // 没有使用传统的方式引入VueRouter
        Vue.use(VueRouter);
      }
      ```

  - *启用现代模式*：

    - 为了兼容各种浏览器，`vue-cli`在内部使用了`@babel/preset-env`对代码进行降级，你可以通过`.browserlistrc`配置来设置需要兼容的目标浏览器

    - 这是一种比较偷懒的办法，因为对于那些使用现代浏览器的用户，它们也被迫使用了降级之后的代码，而降低的代码中包含了大量的`polyfill`，从而提升了包的体积

    - 因此，我们希望提供两种打包结果：

      1. 降级后的包（大），提供给旧浏览器用户使用
      2. 未降级的包（小），提供给现代浏览器用户使用

    - 除了应用webpack进行多次打包外，还可以利用`vue-cli`给我们提供的命令：

      ```sh
      # --modern 面向现代浏览器带自动回退地构建应用
      vue-cli-service build --modern
      ```

- **优化项目包体积**：此处的项目包是指`src`目录中的打包结果

  - *页面分包*：

    - 默认情况下，`vue-cli`会利用webpack将src目录中的所有代码打包成一个bundle，这样就导致访问一个页面时，需要加载所有页面的`js`代码

    - 可以利用webpack对`动态import`的支持，从而达到把不同页面的代码打包到不同文件中：

      ```js
      // routes
      export default [
        {
          name: "Home",
          path: "/",
          component: () => import(/* webpackChunkName: "home" */ "@/views/Home"),
        },
        {
          name: "About",
          path: "/about",
          component: () => import(/* webpackChunkName: "about" */ "@/views/About"),
        }
      ];
      ```

- **优化首屏响应**：

  - 首页白屏受很多因素的影响，例如：vue页面需要通过js构建，因此在js下载到本地之前，页面上什么也没有，就会出现首页白屏

  - 一个非常简单有效的办法，即在页面中先渲染一个小的加载中效果，等到js下载到本地并运行后，即会自动替换：

    ```html
    <div id="app">
      <img src="loading.gif" />
    </div>
    ```



## 异步组件

- **异步组件**：

  - 在代码层面，vue组件本质上是一个配置对象：

    ```js
    var comp = {
      props: xxx,
      data: xxx,
      computed: xxx,
      methods: xxx
    }
    ```

  - 但有的时候，要得到某个组件配置对象需要一个异步的加载过程，比如：

    - 需要使用ajax获得某个数据之后才能加载该组件
    - 为了合理的分包，组件配置对象需要通过`import(xxx)`动态加载

  - 如果一个组件*需要通过异步的方式得到组件配置对象*，则该组件可看作一个异步组件：

    ```js
    /**
     * 异步组件本质上是一个函数
     * 该函数调用后返回一个Promise（import()返回的），resolve成功的结果是一个组件配置对象
     */
    const AsyncComponent = () => import("./MyComp");
    
    var App = {
      components: {
        /**
         * 你可以把该函数当做一个组件使用（异步组件）
         * Vue会调用该函数，并等待Promise完成，完成之前该组件位置什么也不渲染
         */
        AsyncComponent 
      }
    }
    ```

  - 异步组件的函数不仅可以返回一个Promise，还支持返回一个对象，[返回对象格式的异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#处理加载状态)

- **应用**：

  - 异步组件通常应用在路由懒加载中，以达到更好的分包效果

  - 为了提高用户体验，可以在组件配置对象加载完成之前给用户显示一些提示信息：

    ```js
    var routes = [
      {
         path: "/",
         component: async () => {
           console.log("组件开始加载"); 
           const HomeComp = await import("./Views/Home.vue");
           console.log("组件加载完毕");
           return HomeComp;
      	 }
      }
    ];
    ```

  - 推荐使用`NProgress`展现一个进度条
